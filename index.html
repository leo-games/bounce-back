<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bounce Back - Level Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; user-select: none; /* Prevent text selection during drag */ }
        canvas { display: block; background: #f0f8ff; /* Alice Blue */ }
        #contextMenu { position: absolute; display: none; z-index: 10; background-color: white; border-radius: 0.375rem; /* rounded-md */ box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */ border: 1px solid #e5e7eb; /* border-gray-200 */ padding: 0.25rem; /* p-1 */ min-width: 180px; }
        #contextMenu button { display: block; width: 100%; text-align: left; padding: 0.5rem 1rem; /* px-4 py-2 */ font-size: 0.875rem; /* text-sm */ color: #374151; /* text-gray-700 */ border-radius: 0.25rem; /* rounded-sm */ background: none; border: none; cursor: pointer; }
        #contextMenu button:hover { background-color: #f3f4f6; /* hover:bg-gray-100 */ }
        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.75); color: white; padding: 20px 30px; border-radius: 10px; text-align: center; z-index: 20; display: none; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        #messageBox button { margin-top: 1rem; padding: 0.5rem 1rem; background-color: #3b82f6; /* bg-blue-500 */ color: white; border: none; border-radius: 0.375rem; /* rounded-md */ cursor: pointer; transition: background-color 0.15s ease-in-out; }
        #messageBox button:hover { background-color: #2563eb; /* hover:bg-blue-600 */ }
        /* Cursors */
        .cursor-grab { cursor: grab; } .cursor-grabbing { cursor: grabbing; } .cursor-move { cursor: move; } .cursor-crosshair { cursor: crosshair; } .cursor-nwse-resize { cursor: nwse-resize; } .cursor-nesw-resize { cursor: nesw-resize; }
        /* Level List Styling */
        #levelList li { padding: 4px 8px; cursor: pointer; border-radius: 4px; margin-bottom: 2px; border: 1px solid transparent; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.1s ease, border-color 0.1s ease; }
        #levelList li:hover { background-color: #f0f0f0; border-color: #ddd; }
        #levelList li.selected { background-color: #dbeafe; /* blue-100 */ border-color: #93c5fd; /* blue-300 */ font-weight: 500; }
        #levelList li .level-name { flex-grow: 1; margin-right: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: text; /* Indicate renamable */ }
        #levelList li .level-name:hover { text-decoration: underline; } /* Indicate renamable on hover */
        #levelList li .level-controls button { padding: 2px 4px; margin-left: 4px; font-size: 0.75rem; line-height: 1; border-radius: 4px; background-color: #e5e7eb; /* gray-200 */ color: #374151; /* gray-700 */ border: none; cursor: pointer; transition: background-color 0.1s ease; }
        #levelList li .level-controls button:hover:not(:disabled) { background-color: #d1d5db; /* gray-300 */ }
        #levelList li .level-controls button:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Marquee Selection Box */
        #marqueeBox { position: absolute; border: 1px dashed #007bff; background-color: rgba(0, 123, 255, 0.1); display: none; z-index: 5; pointer-events: none; /* Prevent interaction */ }
        /* Editor Controls & Properties Section */
        #editorControls, #brickProperties { border-top: 1px solid #e5e7eb; /* border-gray-200 */ padding-top: 0.75rem; margin-top: 0.75rem; }
        #brickProperties label { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; /* text-sm */ color: #4b5563; /* text-gray-600 */ }
        #brickProperties input[type="number"] { width: 100%; padding: 0.3rem 0.5rem; border: 1px solid #d1d5db; /* border-gray-300 */ border-radius: 0.25rem; /* rounded-sm */ font-size: 0.875rem; /* text-sm */ margin-bottom: 0.5rem; }
        #brickProperties input[type="number"]:disabled { background-color: #f3f4f6; /* bg-gray-100 */ cursor: not-allowed; opacity: 0.7; }
        /* Menu Styling */
        #menu { transition: transform 0.3s ease-out; }
        #menu.hidden { transform: translateX(-110%); }
        #showMenuButton { transition: opacity 0.3s ease-in-out; }
        #showMenuButton.hidden { opacity: 0; pointer-events: none; }
        /* Logo Placeholder Style */
        #logoPlaceholder { display: inline-block; background-color: #e0e0e0; color: #757575; text-align: center; line-height: 4rem; /* Adjust based on height */ font-size: 0.8rem; }

    </style>
</head>
<body class="bg-gray-100">

<button id="showMenuButton" class="absolute top-4 left-4 bg-gray-600 text-white p-2 rounded-md hover:bg-gray-700 transition duration-150 ease-in-out z-20 hidden">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"> <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" /> </svg>
</button>

<div id="menu" class="absolute top-4 left-4 bg-white p-4 rounded-lg shadow-xl z-10 space-y-3 w-64 max-h-[calc(100vh-2rem)] overflow-y-auto">
    <div class="flex justify-center mb-2">
        <img id="gameLogo" src="logo.png" alt="Bounce Back Logo" class="w-20 h-auto rounded" onerror="this.style.display='none'; document.getElementById('logoPlaceholder').style.display='inline-block';">
    </div>
    <h2 class="text-xl font-semibold text-center text-gray-800">Bounce Back</h2>

    <div class="grid grid-cols-2 gap-2">
        <button id="playButton" class="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-150 ease-in-out text-sm font-medium">Play Mode</button>
        <button id="editorButton" class="w-full px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition duration-150 ease-in-out text-sm font-medium">Level Editor</button>
    </div>

    <div class="text-sm text-gray-600 text-center">Playing Level: <span id="levelDisplay" class="font-medium">1</span></div>

    <div id="editorControls" class="hidden space-y-3">
        <h3 class="text-md font-semibold text-center text-gray-700">Level Editor</h3>
        <div class="text-sm text-gray-600 text-center">Editing Level: <span id="editingLevelDisplay" class="font-medium">1</span></div>
        <div class="text-xs text-gray-500 text-center mb-2 p-1 bg-gray-50 rounded border border-gray-200">
            Dbl-Click Name: Rename | Ctrl+Click: Multi-Select | Drag: Marquee | Arrow Keys: Nudge | Ctrl+C/V/Z/Y/Del
        </div>

        <div class="border rounded-md p-2 bg-gray-50 shadow-inner">
            <h4 class="text-sm font-medium mb-1 text-gray-700">Levels:</h4>
            <ul id="levelList" class="text-sm max-h-48 overflow-y-auto mb-2 border rounded bg-white"></ul>
            <div class="grid grid-cols-2 gap-1 mt-2">
                 <button onclick="levelManager.addNew()" class="w-full px-3 py-1 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition duration-150 ease-in-out text-xs">Add New</button>
                 <button onclick="levelManager.importLevels()" class="w-full px-3 py-1 bg-cyan-500 text-white rounded-md hover:bg-cyan-600 transition duration-150 ease-in-out text-xs">Import</button>
                 <button onclick="levelManager.deleteSelected()" class="w-full px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 transition duration-150 ease-in-out text-xs">Delete Sel.</button>
                 <button onclick="levelManager.exportSelected()" class="w-full px-3 py-1 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition duration-150 ease-in-out text-xs">Export Sel.</button>
            </div>
             <input type="file" id="importFile" accept=".json" multiple style="display: none;" onchange="levelManager.handleFileImport(event)">
        </div>
        <button onclick="levelManager.saveCurrentLevel()" id="saveButton" class="w-full px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 transition duration-150 ease-in-out text-sm font-medium">Save Current Level</button>

        <div id="brickProperties" class="hidden space-y-2">
             <h4 class="text-sm font-medium text-center text-gray-700">Brick Properties</h4>
             <div>
                 <label for="propMoveRange">Move Range:</label>
                 <input type="number" id="propMoveRange" name="moveRange" min="0" step="1">
             </div>
             <div>
                 <label for="propMoveSpeed">Move Speed:</label>
                 <input type="number" id="propMoveSpeed" name="moveSpeed" min="0" step="0.1">
             </div>
        </div>
        </div>

    <hr class="mt-4">
    <button onclick="uiManager.hideMenu()" class="w-full mt-2 px-4 py-1 bg-gray-400 text-white rounded-md hover:bg-gray-500 transition duration-150 ease-in-out text-sm">Hide Menu</button>
</div>

<div id="contextMenu"></div>

<div id="messageBox">
    <p id="messageText"></p>
    <button onclick="uiManager.hideMessage()">OK</button>
</div>

<div id="marqueeBox"></div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- DOM Element References ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const menuDiv = document.getElementById("menu");
    const showMenuButton = document.getElementById("showMenuButton");
    const editorControlsDiv = document.getElementById("editorControls");
    const contextMenuDiv = document.getElementById("contextMenu");
    const playButton = document.getElementById("playButton");
    const editorButton = document.getElementById("editorButton");
    const saveButton = document.getElementById("saveButton");
    const levelDisplay = document.getElementById("levelDisplay");
    const editingLevelDisplay = document.getElementById("editingLevelDisplay");
    const levelListElement = document.getElementById("levelList");
    const messageBox = document.getElementById("messageBox");
    const messageText = document.getElementById("messageText");
    const marqueeBox = document.getElementById("marqueeBox");
    const importFileInput = document.getElementById("importFile");
    const brickPropertiesDiv = document.getElementById("brickProperties");
    const propMoveRangeInput = document.getElementById("propMoveRange");
    const propMoveSpeedInput = document.getElementById("propMoveSpeed");


    // --- Game Constants ---
    const PLAYER_WIDTH = 40;
    const PLAYER_HEIGHT = 10;
    const PLAYER_HEAD_RADIUS = 10;
    const BALL_RADIUS = 10;
    const HOLE_RADIUS = 15;
    const AIM_LINE_LENGTH = 100;
    const AIM_POWER_FACTOR = 10.0;
    const AIM_VISUAL_SCALE = 5;
    const MIN_AIM_VY = -0.1;
    const BRICK_COLOR = "#6B7280";
    const BRICK_STROKE_COLOR = "#1F2937";
    const KILL_BRICK_COLOR = "#EF4444";
    const VERTICAL_MOVER_COLOR = "#FACC15";
    const HORIZONTAL_MOVER_COLOR = "#4ADE80";
    const SELECTED_BRICK_COLOR = "#3B82F6";
    const SELECTED_ITEM_OUTLINE_COLOR = "#F59E0B";
    const HANDLE_COLOR = "#F59E0B";
    const HANDLE_SIZE = 5;
    const ROTATE_HANDLE_OFFSET = 20;
    const ROTATE_HANDLE_SIZE_FACTOR = 1.2;
    const MIN_BRICK_DIMENSION = 10;
    const COLLISION_PUSH_FACTOR = 1.01;
    const PLAYER_BOTTOM_OFFSET = 60;
    const HOLE_DEFAULT_Y = 100;
    const BALL_OUTLINE_WIDTH = 2;
    const NUDGE_AMOUNT = 1;
    const PASTE_OFFSET = 15;
    const MAX_HISTORY = 50;
    const MESSAGE_DISPLAY_TIME = 1500;
    const DEFAULT_MOVE_RANGE = 50;
    const DEFAULT_MOVE_SPEED = 1.0;
    const CLICK_THRESHOLD_SQ = 9;
    const MOVER_RANGE_INDICATOR_COLOR = "rgba(100, 100, 255, 0.5)";
    const MOVER_RANGE_INDICATOR_WIDTH = 2;
    const DEFAULT_LEVEL_FILES = [
        './data/levels/Level_1.json',
        './data/levels/Level_2.json',
        './data/levels/Level_3.json'  // Assuming you have this file
    ];


    // --- Game State Variables ---
    let gameState = {
        player: { x: 0, y: 0, width: PLAYER_WIDTH, height: PLAYER_HEIGHT },
        ball: { x: 0, y: 0, radius: BALL_RADIUS, vx: 0, vy: 0, fired: false, onPlayer: true },
        hole: { x: 0, y: 0, radius: HOLE_RADIUS },
        bricks: [],
        currentLevelIndex: 0,
        mode: 'editor',
    };

    // --- Editor State Variables ---
    let editorState = {
        selectedItems: [],
        draggingHandle: null,
        dragStart: { x: 0, y: 0 },
        originalItemStates: [],
        mouse: { x: 0, y: 0, down: false, dragStartX: 0, dragStartY: 0 },
        aim: { dx: 0, dy: 0, active: false },
        isMarqueeSelecting: false,
        marqueeStart: { x: 0, y: 0 },
        marqueeEnd: { x: 0, y: 0 },
        isDraggingSelection: false,
        clipboard: [],
        history: [],
        historyIndex: -1,
        isNudging: false,
        contextMenuTarget: null,
        isUpdatingPropertiesFromInput: false,
    };

    // --- Level Data ---
    let levelManager = {
        levels: [],
        storageKey: 'bounceBackLevels_v1', // *** MODIFIED: Storage key for new name ***

        loadLevelsFromStorage: async function() {
            const storedLevels = localStorage.getItem(this.storageKey);
            let loadedFromStorage = false;
            if (storedLevels) {
                try {
                    const parsedLevels = JSON.parse(storedLevels);
                    if (Array.isArray(parsedLevels) && parsedLevels.length > 0 && typeof parsedLevels[0] === 'object' && parsedLevels[0].bricks) {
                        this.levels = parsedLevels;
                        this.levels.forEach((lvl, index) => this._validateAndDefaultLevel(lvl, index));
                        loadedFromStorage = true;
                        console.log("Loaded levels from localStorage.");
                    } else { console.warn("Invalid level structure in localStorage."); }
                } catch (e) { console.error("Failed to parse levels from localStorage:", e); uiManager.showMessage("Error loading saved levels. Loading defaults.", 3000); this.levels = []; }
            }
            if (!loadedFromStorage) {
                console.log("No valid levels in localStorage, attempting to fetch defaults...");
                try {
                    const responses = await Promise.all( DEFAULT_LEVEL_FILES.map(url => fetch(url)) );
                    const allOk = responses.every(res => res.ok);
                    if (!allOk) { const failed = responses.filter(res => !res.ok); throw new Error(`Failed to fetch default levels: ${failed.map(f => f.url + ' ('+f.statusText+')').join(', ')}`); }
                    const fetchedLevelData = await Promise.all( responses.map(res => res.json()) );
                    if (fetchedLevelData.length > 0) {
                        this.levels = fetchedLevelData;
                        this.levels.forEach((lvl, index) => this._validateAndDefaultLevel(lvl, index));
                        console.log(`Successfully fetched and validated ${this.levels.length} default levels.`);
                        this.saveLevelsToStorage();
                    } else { throw new Error("Fetched default level data was empty."); }
                } catch (fetchError) {
                    console.error("Failed to fetch or process default levels:", fetchError);
                    uiManager.showMessage("Could not load default levels. Using fallback.", 3000);
                    this.levels = [this._createDefaultLevelData(0)];
                }
            }
            if (this.levels.length === 0) { console.warn("Level loading resulted in empty array, creating fallback."); this.levels = [this._createDefaultLevelData(0)]; }
            gameState.currentLevelIndex = 0;
            this.populateLevelList();
        },
        saveLevelsToStorage: function() { try { localStorage.setItem(this.storageKey, JSON.stringify(this.levels)); console.log("Saved levels to localStorage."); } catch (e) { console.error("Failed to save levels to localStorage:", e); uiManager.showMessage("Error saving levels. Storage might be full.", 3000); } },
        _validateAndDefaultLevel: function(lvl, index) { const defaultLvl = this._createDefaultLevelData(index); if (typeof lvl !== 'object' || lvl === null) return; lvl.name = lvl.name || `Level ${index + 1}`; lvl.player = lvl.player || defaultLvl.player; if (lvl.player && !lvl.player.yOffset) lvl.player.yOffset = PLAYER_BOTTOM_OFFSET; lvl.hole = lvl.hole || defaultLvl.hole; lvl.bricks = Array.isArray(lvl.bricks) ? lvl.bricks : defaultLvl.bricks; lvl.bricks.forEach(brick => { if (typeof brick !== 'object' || brick === null) return; brick.isKillBrick = brick.isKillBrick || false; brick.movementType = brick.movementType || null; brick.moveRange = brick.moveRange ?? DEFAULT_MOVE_RANGE; brick.moveSpeed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED; brick.angle = brick.angle || 0; brick.x = brick.x ?? 0; brick.y = brick.y ?? 0; brick.width = brick.width ?? 100; brick.height = brick.height ?? 20; }); },
        _createDefaultLevelData: function(levelIndex = 0) { console.log("Creating fallback default level data."); const fallbackBricks = [ { x: -150, y: 300, width: 200, height: 15, angle: -Math.PI / 16, isKillBrick: false, movementType: null, moveRange: DEFAULT_MOVE_RANGE, moveSpeed: DEFAULT_MOVE_SPEED }, { x: 0, y: 180, width: 100, height: 15, angle: 0, isKillBrick: false, movementType: 'horizontal', moveRange: 80, moveSpeed: 1.5 }, { x: 150, y: 250, width: 15, height: 80, angle: 0, isKillBrick: true, movementType: 'vertical', moveRange: 40, moveSpeed: 0.8 } ]; return { name: `Fallback Level ${levelIndex + 1}`, bricks: fallbackBricks, player: { relX: 0, yOffset: PLAYER_BOTTOM_OFFSET }, hole: { relX: 0, y: HOLE_DEFAULT_Y } }; },
        loadLevelData: function(index) { if (index < 0 || index >= this.levels.length) { console.error("Attempted to load invalid level index:", index); index = 0; if (this.levels.length === 0) { this.levels.push(this._createDefaultLevelData(0)); } } const levelData = this.levels[index]; if (typeof levelData !== 'object' || levelData === null || !Array.isArray(levelData.bricks)) { console.error("Invalid level data structure at index:", index, levelData); uiManager.showMessage(`Error: Corrupted level data for Level ${index + 1}.`, 3000); return; } const centerX = canvas.width / 2; gameState.bricks = levelData.bricks.map(brickData => { if (typeof brickData !== 'object' || brickData === null) { console.warn("Skipping invalid brick data during load:", brickData); return null; } const initialAbsX = centerX + (brickData.x || 0); const initialAbsY = brickData.y || 0; return { ...brickData, x: initialAbsX, y: initialAbsY, initialX: initialAbsX, initialY: initialAbsY, isKillBrick: brickData.isKillBrick || false, movementType: brickData.movementType || null, moveRange: brickData.moveRange ?? DEFAULT_MOVE_RANGE, moveSpeed: brickData.moveSpeed ?? DEFAULT_MOVE_SPEED, angle: brickData.angle || 0, width: brickData.width ?? 100, height: brickData.height ?? 20, }; }).filter(brick => brick !== null); const playerDefaults = this._createDefaultLevelData(0).player; const currentPlayerData = levelData.player || playerDefaults; gameState.player.x = centerX + (currentPlayerData.relX || 0); gameState.player.y = canvas.height - (currentPlayerData.yOffset || PLAYER_BOTTOM_OFFSET); const holeDefaults = this._createDefaultLevelData(0).hole; const currentHoleData = levelData.hole || holeDefaults; gameState.hole.x = centerX + (currentHoleData.relX || 0); gameState.hole.y = currentHoleData.y || HOLE_DEFAULT_Y; gameState.currentLevelIndex = index; uiManager.updateLevelDisplays(); gameLogic.resetBall(); editor.resetSelectionAndHistory(); historyManager.saveState(true); uiManager.updateBrickPropertiesUI(); },
        saveCurrentLevel: function() { if (gameState.mode !== 'editor') return; const index = gameState.currentLevelIndex; if (index < 0 || index >= this.levels.length) { console.error("Cannot save, invalid level index selected:", index); uiManager.showMessage("Error: Invalid level selected for saving.", 2000); return; } const centerX = canvas.width / 2; const levelData = this.levels[index]; levelData.bricks = gameState.bricks.map(brick => { const savedRelX = (brick.initialX !== undefined ? brick.initialX : brick.x) - centerX; const savedAbsY = brick.initialY !== undefined ? brick.initialY : brick.y; return { x: savedRelX, y: savedAbsY, width: brick.width, height: brick.height, angle: brick.angle || 0, isKillBrick: brick.isKillBrick || false, movementType: brick.movementType || null, moveRange: brick.moveRange ?? DEFAULT_MOVE_RANGE, moveSpeed: brick.moveSpeed ?? DEFAULT_MOVE_SPEED, }; }); levelData.player = { relX: gameState.player.x - centerX, yOffset: canvas.height - gameState.player.y }; levelData.hole = { relX: gameState.hole.x - centerX, y: gameState.hole.y }; this.saveLevelsToStorage(); uiManager.showMessage(`Level ${index + 1} ('${levelData.name}') saved!`, 1500); this.populateLevelList(); },
        populateLevelList: function() { levelListElement.innerHTML = ''; if (!Array.isArray(this.levels)) { console.error("Cannot populate level list: levels data is not an array."); this.levels = []; return; } this.levels.forEach((levelData, index) => { if (typeof levelData !== 'object' || levelData === null) { console.warn(`Skipping invalid level data at index ${index} in populateLevelList.`); return; } const li = document.createElement('li'); li.onclick = (e) => { if (e.target.closest('.level-controls')) return; this.selectLevelToEdit(index); }; if (index === gameState.currentLevelIndex) { li.classList.add('selected'); } const nameSpan = document.createElement('span'); nameSpan.className = 'level-name'; nameSpan.textContent = levelData.name || `Level ${index + 1}`; nameSpan.title = "Double-click to rename"; nameSpan.ondblclick = (e) => { e.stopPropagation(); this.renameLevel(index); }; li.appendChild(nameSpan); const controlsDiv = document.createElement('div'); controlsDiv.className = 'level-controls'; const upButton = uiManager.createLevelControlButton('&uarr;', "Move Up", () => this.moveLevelUp(index), index === 0); const downButton = uiManager.createLevelControlButton('&darr;', "Move Down", () => this.moveLevelDown(index), index === this.levels.length - 1); controlsDiv.appendChild(upButton); controlsDiv.appendChild(downButton); li.appendChild(controlsDiv); levelListElement.appendChild(li); }); uiManager.updateLevelDisplays(); },
        selectLevelToEdit: function(index) { if (index >= 0 && index < this.levels.length) { this.loadLevelData(index); this.populateLevelList(); if (gameState.mode === 'play') { gameLogic.startGame(); } else { drawing.draw(); } } else { console.error("Invalid level index selected:", index); } },
        renameLevel: function(index) { if (index < 0 || index >= this.levels.length) return; const currentName = this.levels[index].name || `Level ${index + 1}`; const newName = prompt(`Enter new name for "${currentName}":`, currentName); if (newName === null) return; const trimmedName = newName.trim(); if (trimmedName === '') { uiManager.showMessage("Level name cannot be empty.", 2000); return; } if (trimmedName !== currentName) { this.levels[index].name = trimmedName; this.saveLevelsToStorage(); this.populateLevelList(); uiManager.showMessage(`Level ${index + 1} renamed to "${trimmedName}"`, 1500); } },
        addNew: function() { historyManager.saveState(); this.levels.push(this._createDefaultLevelData(this.levels.length)); this.saveLevelsToStorage(); this.selectLevelToEdit(this.levels.length - 1); uiManager.showMessage(`Added new Level ${this.levels.length}`, 1500); },
        deleteSelected: function() { const index = gameState.currentLevelIndex; if (this.levels.length <= 1) { uiManager.showMessage("Cannot delete the last level!", 2000); return; } if (confirm(`Are you sure you want to delete Level ${index + 1} ('${this.levels[index].name}')? This cannot be undone.`)) { historyManager.saveState(); this.levels.splice(index, 1); this.saveLevelsToStorage(); const newIndex = Math.max(0, index - 1); this.selectLevelToEdit(newIndex); uiManager.showMessage(`Deleted Level ${index + 1}`, 1500); } },
        moveLevelUp: function(index) { if (index > 0) { historyManager.saveState(); [this.levels[index], this.levels[index - 1]] = [this.levels[index - 1], this.levels[index]]; this.saveLevelsToStorage(); this.selectLevelToEdit(index - 1); } },
        moveLevelDown: function(index) { if (index < this.levels.length - 1) { historyManager.saveState(); [this.levels[index], this.levels[index + 1]] = [this.levels[index + 1], this.levels[index]]; this.saveLevelsToStorage(); this.selectLevelToEdit(index + 1); } },
        exportSelected: function() { const index = gameState.currentLevelIndex; if (index < 0 || index >= this.levels.length) { uiManager.showMessage("No level selected to export.", 2000); return; } try { this.saveCurrentLevel(); const levelDataToExport = utils.deepClone(this.levels[index]); const levelJson = JSON.stringify(levelDataToExport, null, 2); const levelName = utils.sanitizeFilename(levelDataToExport.name || `level_${index + 1}`); const filename = `${levelName}.json`; const blob = new Blob([levelJson], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); uiManager.showMessage(`Level '${levelDataToExport.name}' exported as ${filename}`, 2000); } catch (error) { console.error("Export failed:", error); uiManager.showMessage("Failed to export level.", 2000); } },
        importLevels: function() { importFileInput.click(); },
        handleFileImport: function(event) { const files = event.target.files; if (!files || files.length === 0) { return; } historyManager.saveState(); let importedCount = 0; let failedCount = 0; const promises = []; Array.from(files).forEach(file => { promises.push(new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { try { const levelData = JSON.parse(e.target.result); this._validateAndDefaultLevel(levelData, this.levels.length); if (typeof levelData !== 'object' || !levelData.name || !levelData.bricks) { throw new Error(`Invalid level structure after validation in file ${file.name}.`); } this.levels.push(levelData); importedCount++; resolve(); } catch (error) { console.error(`Failed to parse or validate file ${file.name}:`, error); failedCount++; reject(error); } }; reader.onerror = (e) => { console.error(`Failed to read file ${file.name}:`, e); failedCount++; reject(e); }; reader.readAsText(file); })); }); Promise.allSettled(promises).then(() => { let message = ""; if (importedCount > 0) { message += `Imported ${importedCount} level(s). `; this.saveLevelsToStorage(); this.populateLevelList(); this.selectLevelToEdit(this.levels.length - 1); } if (failedCount > 0) { message += `${failedCount} import(s) failed. Check console for details.`; } if (message) { uiManager.showMessage(message, importedCount > 0 ? 2500 : 3000); } event.target.value = null; }); },
    };

    // --- Vector Math Helper --- (No Changes)
    const Vec = { create: (x = 0, y = 0) => ({ x, y }), add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }), sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }), scale: (v, s) => ({ x: v.x * s, y: v.y * s }), dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y, lenSq: (v) => v.x * v.x + v.y * v.y, len: (v) => Math.sqrt(Vec.lenSq(v)), normalize: (v) => { const l = Vec.len(v); return l === 0 ? Vec.create() : Vec.scale(v, 1 / l); }, perp: (v) => ({ x: -v.y, y: v.x }), reflect: (v, normal) => { const d = Vec.dot(v, normal); return Vec.sub(v, Vec.scale(normal, 2 * d)); }, rotate: (v, angle) => { const cosA = Math.cos(angle); const sinA = Math.sin(angle); return { x: v.x * cosA - v.y * sinA, y: v.x * sinA + v.y * cosA }; } };

    // --- Utility Functions --- (No Changes)
    const utils = { resizeCanvas: () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; levelManager.loadLevelData(gameState.currentLevelIndex); drawing.draw(); }, getRectVertices: (rect) => { const hw = rect.width / 2; const hh = rect.height / 2; const cx = rect.x + hw; const cy = rect.y + hh; const angle = rect.angle || 0; const cosA = Math.cos(angle); const sinA = Math.sin(angle); const corners = [ { x: -hw, y: -hh }, { x: hw, y: -hh }, { x: hw, y: hh }, { x: -hw, y: hh } ]; return corners.map(corner => ({ x: cx + (corner.x * cosA - corner.y * sinA), y: cy + (corner.x * sinA + corner.y * cosA) })); }, getRectAxes: (vertices) => { const axes = []; for (let i = 0; i < vertices.length; i++) { const p1 = vertices[i]; const p2 = vertices[(i + 1) % vertices.length]; const edge = Vec.sub(p2, p1); const normal = Vec.normalize(Vec.perp(edge)); if (!axes.some(ax => Math.abs(Vec.dot(ax, normal)) > 0.999)) { axes.push(normal); } } return axes; }, projectShapeOntoAxis: (vertices, axis) => { let min = Vec.dot(vertices[0], axis); let max = min; for (let i = 1; i < vertices.length; i++) { const p = Vec.dot(vertices[i], axis); if (p < min) min = p; else if (p > max) max = p; } return { min, max }; }, projectCircleOntoAxis: (circle, axis) => { const centerProj = Vec.dot(Vec.create(circle.x, circle.y), axis); return { min: centerProj - circle.radius, max: centerProj + circle.radius }; }, checkCircleRectCollision: (circle, rect) => { const rectVertices = utils.getRectVertices(rect); const circleCenter = Vec.create(circle.x, circle.y); const rectCenter = Vec.create(rect.x + rect.width / 2, rect.y + rect.height / 2); const axes = utils.getRectAxes(rectVertices); let closestVertex = rectVertices[0]; let minDistSq = Vec.lenSq(Vec.sub(circleCenter, closestVertex)); for (let i = 1; i < rectVertices.length; i++) { const distSq = Vec.lenSq(Vec.sub(circleCenter, rectVertices[i])); if (distSq < minDistSq) { minDistSq = distSq; closestVertex = rectVertices[i]; } } const axisToClosestVertex = Vec.normalize(Vec.sub(circleCenter, closestVertex)); if (Vec.lenSq(axisToClosestVertex) > 0.0001 && !axes.some(ax => Math.abs(Vec.dot(ax, axisToClosestVertex)) > 0.999)) { axes.push(axisToClosestVertex); } let minOverlap = Infinity; let mtvAxis = null; for (const axis of axes) { const rectProj = utils.projectShapeOntoAxis(rectVertices, axis); const circleProj = utils.projectCircleOntoAxis(circle, axis); const overlap = Math.min(rectProj.max, circleProj.max) - Math.max(rectProj.min, circleProj.min); if (overlap <= 0) { return { collision: false }; } if (overlap < minOverlap) { minOverlap = overlap; mtvAxis = axis; } } const centerDirection = Vec.sub(circleCenter, rectCenter); if (Vec.dot(mtvAxis, centerDirection) < 0) { mtvAxis = Vec.scale(mtvAxis, -1); } return { collision: true, normal: mtvAxis, overlap: minOverlap }; }, isPointInRotatedRect: (px, py, rect) => { const hw = rect.width / 2; const hh = rect.height / 2; const cx = rect.x + hw; const cy = rect.y + hh; const angle = -(rect.angle || 0); const cosA = Math.cos(angle); const sinA = Math.sin(angle); const dx = px - cx; const dy = py - cy; const localX = dx * cosA - dy * sinA; const localY = dx * sinA + dy * cosA; return Math.abs(localX) <= hw && Math.abs(localY) <= hh; }, getBrickHandles: (brick) => { const hw = brick.width / 2; const hh = brick.height / 2; const cx = brick.x + hw; const cy = brick.y + hh; const angle = brick.angle || 0; const cosA = Math.cos(angle); const sinA = Math.sin(angle); const rotatePoint = (relX, relY) => ({ x: cx + (relX * cosA - relY * sinA), y: cy + (relX * sinA + relY * cosA) }); return { tl: rotatePoint(-hw, -hh), tr: rotatePoint(hw, -hh), bl: rotatePoint(-hw, hh), br: rotatePoint(hw, hh), rotate: rotatePoint(0, -hh - ROTATE_HANDLE_OFFSET), center: { x: cx, y: cy } }; }, deepClone: (obj) => { try { return JSON.parse(JSON.stringify(obj)); } catch (e) { console.error("Deep clone failed:", e, obj); return null; } }, selectionsAreEqual: (selA, selB) => { if (selA.length !== selB.length) return false; const sortFn = (a, b) => (a.type + a.index).localeCompare(b.type + b.index); const sortedA = [...selA].sort(sortFn); const sortedB = [...selB].sort(sortFn); return sortedA.every((item, i) => item.type === sortedB[i].type && item.index === sortedB[i].index); }, getRectBoundingBox: (rect) => { const vertices = utils.getRectVertices(rect); let minX = vertices[0].x, maxX = vertices[0].x, minY = vertices[0].y, maxY = vertices[0].y; for (let i = 1; i < vertices.length; i++) { minX = Math.min(minX, vertices[i].x); maxX = Math.max(maxX, vertices[i].x); minY = Math.min(minY, vertices[i].y); maxY = Math.max(maxY, vertices[i].y); } return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; }, doRectsOverlap: (rect1, rect2) => { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }, sanitizeFilename: (name) => { if (!name) return 'level'; return name.replace(/[^a-z0-9_\-\s.]/gi, '_').replace(/[\s_]+/g, '_'); }, statesAreEqual: (stateA, stateB) => { try { return JSON.stringify(stateA) === JSON.stringify(stateB); } catch (e) { console.error("State comparison failed:", e); return false; } } };

    // --- History / Undo-Redo Manager --- (No Changes)
    const historyManager = { getCurrentStateSnapshot: () => { return { bricks: utils.deepClone(gameState.bricks), player: utils.deepClone(gameState.player), hole: utils.deepClone(gameState.hole), }; }, saveState: (forceSave = false) => { if (!forceSave && editorState.isNudging) return; editorState.isNudging = false; const currentState = historyManager.getCurrentStateSnapshot(); if (editorState.historyIndex >= 0 && utils.statesAreEqual(currentState, editorState.history[editorState.historyIndex])) { return; } editorState.history = editorState.history.slice(0, editorState.historyIndex + 1); editorState.history.push(currentState); editorState.historyIndex++; if (editorState.history.length > MAX_HISTORY) { editorState.history.shift(); editorState.historyIndex--; } }, loadStateFromHistory: (stateData) => { if (!stateData) return; gameState.bricks = utils.deepClone(stateData.bricks); gameState.player = utils.deepClone(stateData.player); gameState.hole = utils.deepClone(stateData.hole); if (gameState.ball.onPlayer) { gameLogic.resetBallPosition(); } }, undo: () => { if (gameState.mode !== 'editor' || editorState.historyIndex <= 0) return; editorState.historyIndex--; const stateToLoad = editorState.history[editorState.historyIndex]; historyManager.loadStateFromHistory(stateToLoad); editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, redo: () => { if (gameState.mode !== 'editor' || editorState.historyIndex >= editorState.history.length - 1) return; editorState.historyIndex++; const stateToLoad = editorState.history[editorState.historyIndex]; historyManager.loadStateFromHistory(stateToLoad); editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); } };

    // --- UI Manager --- (No Changes except updateBrickPropertiesUI added previously)
    const uiManager = { messageTimeoutId: null, hideMenu: () => { menuDiv.classList.add('hidden'); showMenuButton.classList.remove('hidden'); }, showMenu: () => { menuDiv.classList.remove('hidden'); showMenuButton.classList.add('hidden'); }, showMessage: (text, duration = MESSAGE_DISPLAY_TIME) => { messageText.textContent = text; messageBox.style.display = 'block'; if (uiManager.messageTimeoutId) { clearTimeout(uiManager.messageTimeoutId); } if (duration > 0) { uiManager.messageTimeoutId = setTimeout(uiManager.hideMessage, duration); } }, hideMessage: () => { messageBox.style.display = 'none'; if (uiManager.messageTimeoutId) { clearTimeout(uiManager.messageTimeoutId); uiManager.messageTimeoutId = null; } }, updateUIForMode: () => { const isEditor = gameState.mode === 'editor'; editorControlsDiv.classList.toggle('hidden', !isEditor); saveButton.classList.toggle('hidden', !isEditor); editorButton.classList.toggle('bg-red-500', isEditor); editorButton.classList.toggle('hover:bg-red-600', isEditor); editorButton.classList.toggle('bg-green-500', !isEditor); editorButton.classList.toggle('hover:bg-green-600', !isEditor); playButton.classList.toggle('bg-red-500', !isEditor); playButton.classList.toggle('hover:bg-red-600', !isEditor); playButton.classList.toggle('bg-blue-500', isEditor); playButton.classList.toggle('hover:bg-blue-600', isEditor); uiManager.updateCursorStyle(editorState.mouse.x, editorState.mouse.y); uiManager.updateBrickPropertiesUI(); }, updateLevelDisplays: () => { const displayLevel = gameState.currentLevelIndex + 1; levelDisplay.textContent = displayLevel; editingLevelDisplay.textContent = displayLevel; }, showContextMenu: (x, y) => { contextMenuDiv.innerHTML = ''; const target = editorState.contextMenuTarget; if (target) { if (target.type === 'empty') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Brick', () => editor.addBrick('static'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Kill Brick', () => editor.addBrick('kill'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Vertical Mover', () => editor.addBrick('vertical'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Horizontal Mover', () => editor.addBrick('horizontal'))); if (editorState.clipboard.length > 0) { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Paste', editor.handlePaste)); } } else if (target.type === 'brick' && target.index !== undefined) { const index = target.index; const brick = gameState.bricks[index]; if (!brick) return; const toggleKillText = brick.isKillBrick ? 'Make Normal Brick' : 'Make Kill Brick'; contextMenuDiv.appendChild(uiManager.createContextMenuButton(toggleKillText, () => editor.toggleKillBrick(index))); contextMenuDiv.appendChild(document.createElement('hr')); if (brick.movementType !== 'vertical') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Vertical Mover', () => editor.setMovementType(index, 'vertical'))); } if (brick.movementType !== 'horizontal') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Horizontal Mover', () => editor.setMovementType(index, 'horizontal'))); } if (brick.movementType !== null) { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Static', () => editor.setMovementType(index, null))); } contextMenuDiv.appendChild(document.createElement('hr')); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Copy', editor.handleCopy)); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Delete Brick', () => editor.deleteSingleBrick(index))); } } contextMenuDiv.style.left = `${x}px`; contextMenuDiv.style.top = `${y}px`; contextMenuDiv.style.display = 'block'; }, hideContextMenu: () => { contextMenuDiv.style.display = 'none'; editorState.contextMenuTarget = null; }, createContextMenuButton: (text, onClickAction) => { const button = document.createElement('button'); button.textContent = text; button.onclick = () => { onClickAction(); uiManager.hideContextMenu(); }; return button; }, createLevelControlButton: (html, title, onClickAction, disabled = false) => { const button = document.createElement('button'); button.innerHTML = html; button.title = title; button.disabled = disabled; button.onclick = (e) => { e.stopPropagation(); onClickAction(); }; return button; }, updateCursorStyle: (mx, my) => { if (gameState.mode !== 'editor' || uiManager.isPointerOverUI(mx, my)) { canvas.style.cursor = 'default'; return; } let cursorSet = false; if (editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brick = gameState.bricks[editorState.selectedItems[0].index]; if (brick) { const handles = utils.getBrickHandles(brick); if (Math.hypot(mx - handles.rotate.x, my - handles.rotate.y) <= HANDLE_SIZE * 1.5) { canvas.style.cursor = 'grab'; cursorSet = true; } else { for (const type of ['tl', 'tr', 'bl', 'br']) { if (Math.hypot(mx - handles[type].x, my - handles[type].y) <= HANDLE_SIZE * 1.2) { canvas.style.cursor = (type === 'tl' || type === 'br') ? 'nwse-resize' : 'nesw-resize'; cursorSet = true; break; } } } } } if (!cursorSet && editorState.selectedItems.length > 0) { const isOverSelection = editor.isPointOverSelection(mx, my); if (isOverSelection) { canvas.style.cursor = 'move'; cursorSet = true; } } if (!cursorSet) { const isOverAnyItem = editor.getItemAtPoint(mx, my) !== null; if (isOverAnyItem) { canvas.style.cursor = 'pointer'; cursorSet = true; } } if (!cursorSet) { canvas.style.cursor = 'default'; } }, isPointerOverUI: (px, py) => { if (!menuDiv.classList.contains('hidden')) { const menuRect = menuDiv.getBoundingClientRect(); if (px >= menuRect.left && px <= menuRect.right && py >= menuRect.top && py <= menuRect.bottom) { return true; } } if (!showMenuButton.classList.contains('hidden')) { const buttonRect = showMenuButton.getBoundingClientRect(); if (px >= buttonRect.left && px <= buttonRect.right && py >= buttonRect.top && py <= buttonRect.bottom) { return true; } } return false; }, updateMarqueeBox: () => { if (editorState.isMarqueeSelecting) { const x = Math.min(editorState.marqueeStart.x, editorState.marqueeEnd.x); const y = Math.min(editorState.marqueeStart.y, editorState.marqueeEnd.y); const width = Math.abs(editorState.marqueeStart.x - editorState.marqueeEnd.x); const height = Math.abs(editorState.marqueeStart.y - editorState.marqueeEnd.y); marqueeBox.style.left = `${x}px`; marqueeBox.style.top = `${y}px`; marqueeBox.style.width = `${width}px`; marqueeBox.style.height = `${height}px`; marqueeBox.style.display = 'block'; } else { marqueeBox.style.display = 'none'; } }, updateBrickPropertiesUI: () => { if (editorState.isUpdatingPropertiesFromInput) return; if (gameState.mode === 'editor' && editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brick = gameState.bricks[editorState.selectedItems[0].index]; if (brick) { brickPropertiesDiv.classList.remove('hidden'); const isMover = brick.movementType === 'vertical' || brick.movementType === 'horizontal'; propMoveRangeInput.disabled = !isMover; propMoveSpeedInput.disabled = !isMover; propMoveRangeInput.value = isMover ? (brick.moveRange ?? DEFAULT_MOVE_RANGE) : ''; propMoveSpeedInput.value = isMover ? (brick.moveSpeed ?? DEFAULT_MOVE_SPEED) : ''; propMoveRangeInput.placeholder = isMover ? '' : 'N/A (Static)'; propMoveSpeedInput.placeholder = isMover ? '' : 'N/A (Static)'; return; } } brickPropertiesDiv.classList.add('hidden'); } };

    // --- Game Logic --- (No Changes)
    const gameLogic = { update: () => { if (gameState.mode === 'play') { const time = Date.now() * 0.001; gameState.bricks.forEach(brick => { if (brick.movementType && brick.initialX !== undefined && brick.initialY !== undefined) { const speed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED; const range = brick.moveRange ?? DEFAULT_MOVE_RANGE; const offset = range * Math.sin(time * speed); if (brick.movementType === 'vertical') { brick.y = brick.initialY + offset; } else if (brick.movementType === 'horizontal') { brick.x = brick.initialX + offset; } } }); } if (gameState.mode === 'editor') return; if (gameState.ball.fired) { gameState.ball.x += gameState.ball.vx; gameState.ball.y += gameState.ball.vy; if (gameState.ball.x - gameState.ball.radius < 0) { gameLogic.restartLevelAttempt("Hit left edge!"); return; } if (gameState.ball.x + gameState.ball.radius > canvas.width) { gameLogic.restartLevelAttempt("Hit right edge!"); return; } if (gameState.ball.y - gameState.ball.radius < 0) { gameLogic.restartLevelAttempt("Hit top edge!"); return; } if (gameState.ball.y > canvas.height + gameState.ball.radius * 2) { gameLogic.restartLevelAttempt("Fell off bottom!"); return; } for (const brick of gameState.bricks) { const collision = utils.checkCircleRectCollision(gameState.ball, brick); if (collision.collision) { if (brick.isKillBrick) { gameLogic.restartLevelAttempt("Hit a kill brick!"); return; } const pushVector = Vec.scale(collision.normal, collision.overlap * COLLISION_PUSH_FACTOR); gameState.ball.x += pushVector.x; gameState.ball.y += pushVector.y; const velocity = Vec.create(gameState.ball.vx, gameState.ball.vy); const reflectedVel = Vec.reflect(velocity, collision.normal); gameState.ball.vx = reflectedVel.x; gameState.ball.vy = reflectedVel.y; } } const playerRect = { x: gameState.player.x, y: gameState.player.y, width: gameState.player.width, height: gameState.player.height }; const ballRect = { x: gameState.ball.x - gameState.ball.radius, y: gameState.ball.y - gameState.ball.radius, width: gameState.ball.radius * 2, height: gameState.ball.radius * 2 }; if (!gameState.ball.onPlayer && utils.doRectsOverlap(ballRect, playerRect)) { gameLogic.restartLevelAttempt("Ball hit player!"); return; } const distToHole = Math.hypot(gameState.ball.x - gameState.hole.x, gameState.ball.y - gameState.hole.y); if (distToHole < gameState.ball.radius + gameState.hole.radius) { uiManager.showMessage(`Level ${gameState.currentLevelIndex + 1} Complete!`); const nextLevelIndex = gameState.currentLevelIndex + 1; if (nextLevelIndex < levelManager.levels.length) { levelManager.selectLevelToEdit(nextLevelIndex); gameLogic.startGame(); } else { uiManager.showMessage("Congratulations! You beat all levels!", 0); gameLogic.switchToEditorMode(); } return; } } else if (gameState.ball.onPlayer) { gameLogic.resetBallPosition(); } }, resetBall: () => { gameState.ball.fired = false; gameState.ball.onPlayer = true; gameState.ball.vx = 0; gameState.ball.vy = 0; editorState.aim.active = false; editorState.aim.dx = 0; editorState.aim.dy = 0; gameLogic.resetBallPosition(); }, resetBallPosition: () => { gameState.ball.x = gameState.player.x + gameState.player.width / 2; gameState.ball.y = gameState.player.y - gameState.ball.radius - 2; }, fireBall: () => { if (!gameState.ball.onPlayer || gameState.mode === 'editor' || !editorState.aim.active) return; if (Math.abs(editorState.aim.dx) < 0.01 && Math.abs(editorState.aim.dy) < 0.01) return; gameState.ball.fired = true; gameState.ball.onPlayer = false; gameState.ball.vx = editorState.aim.dx; gameState.ball.vy = editorState.aim.dy; editorState.aim.active = false; editorState.aim.dx = 0; editorState.aim.dy = 0; }, restartLevelAttempt: (reason = "Hazard hit!") => { uiManager.showMessage(`${reason} Restarting level.`, MESSAGE_DISPLAY_TIME); gameLogic.resetBall(); drawing.draw(); }, startGame: () => { gameState.mode = 'play'; editorState.aim.active = false; uiManager.hideContextMenu(); uiManager.hideMessage(); editor.resetSelectionAndDragging(); levelManager.loadLevelData(gameState.currentLevelIndex); uiManager.updateUIForMode(); drawing.draw(); }, switchToEditorMode: () => { gameState.mode = 'editor'; editorState.aim.active = false; uiManager.hideContextMenu(); levelManager.loadLevelData(gameState.currentLevelIndex); uiManager.updateUIForMode(); drawing.draw(); } };

    // --- Drawing Functions --- (No Changes except drawEditorOverlays added previously)
    const drawing = { draw: () => { ctx.fillStyle = "#f0f8ff"; ctx.fillRect(0, 0, canvas.width, canvas.height); drawing.drawHole(); gameState.bricks.forEach((brick, index) => { drawing.drawBrick(brick, index); }); drawing.drawPlayer(); drawing.drawBall(); if (gameState.mode === 'play' && editorState.aim.active && gameState.ball.onPlayer) { drawing.drawAimLine(); } if (gameState.mode === 'editor') { drawing.drawEditorOverlays(); } }, drawHole: () => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'hole'); ctx.fillStyle = "#222"; ctx.beginPath(); ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius, 0, Math.PI * 2); ctx.fill(); if (isSelected) { ctx.strokeStyle = SELECTED_ITEM_OUTLINE_COLOR; ctx.lineWidth = 2; ctx.stroke(); } }, drawBrick: (brick, index) => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'brick' && item.index === index); ctx.save(); const centerX = brick.x + brick.width / 2; const centerY = brick.y + brick.height / 2; ctx.translate(centerX, centerY); ctx.rotate(brick.angle || 0); ctx.translate(-centerX, -centerY); let fillColor = BRICK_COLOR; if (brick.isKillBrick) { fillColor = KILL_BRICK_COLOR; } else if (brick.movementType === 'vertical') { fillColor = VERTICAL_MOVER_COLOR; } else if (brick.movementType === 'horizontal') { fillColor = HORIZONTAL_MOVER_COLOR; } if (isSelected) { fillColor = SELECTED_BRICK_COLOR; } ctx.fillStyle = fillColor; ctx.strokeStyle = BRICK_STROKE_COLOR; ctx.lineWidth = 1; ctx.fillRect(brick.x, brick.y, brick.width, brick.height); ctx.strokeRect(brick.x, brick.y, brick.width, brick.height); ctx.restore(); }, drawPlayer: () => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'player'); const player = gameState.player; ctx.fillStyle = "#4CAF50"; ctx.fillRect(player.x, player.y, player.width, player.height); const headX = player.x + player.width / 2; const headY = player.y - PLAYER_HEAD_RADIUS; ctx.fillStyle = "#8BC34A"; ctx.beginPath(); ctx.arc(headX, headY, PLAYER_HEAD_RADIUS, 0, Math.PI * 2); ctx.fill(); if (isSelected) { ctx.strokeStyle = SELECTED_ITEM_OUTLINE_COLOR; ctx.lineWidth = 2; ctx.strokeRect(player.x, player.y, player.width, player.height); ctx.beginPath(); ctx.arc(headX, headY, PLAYER_HEAD_RADIUS, 0, Math.PI * 2); ctx.stroke(); } }, drawBall: () => { ctx.save(); ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = BALL_OUTLINE_WIDTH; ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore(); }, drawAimLine: () => { ctx.beginPath(); ctx.moveTo(gameState.ball.x, gameState.ball.y); const potentialVx = editorState.aim.dx; const potentialVy = editorState.aim.dy; const endX = gameState.ball.x + potentialVx * AIM_VISUAL_SCALE; const endY = gameState.ball.y + potentialVy * AIM_VISUAL_SCALE; ctx.lineTo(endX, endY); ctx.strokeStyle = "rgba(255, 0, 0, 0.7)"; ctx.lineWidth = 2; ctx.setLineDash([5, 3]); ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.arc(endX, endY, 3, 0, Math.PI * 2); ctx.fillStyle = "rgba(255, 0, 0, 0.7)"; ctx.fill(); }, drawEditorOverlays: () => { if (editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brick = gameState.bricks[editorState.selectedItems[0].index]; if (brick) { if (brick.movementType === 'vertical' || brick.movementType === 'horizontal') { drawing.drawMovementRange(brick); } drawing.drawHandles(brick); } } }, drawMovementRange: (brick) => { const range = brick.moveRange ?? DEFAULT_MOVE_RANGE; const initialCenterX = (brick.initialX ?? brick.x) + brick.width / 2; const initialCenterY = (brick.initialY ?? brick.y) + brick.height / 2; ctx.save(); ctx.strokeStyle = MOVER_RANGE_INDICATOR_COLOR; ctx.lineWidth = MOVER_RANGE_INDICATOR_WIDTH; ctx.setLineDash([4, 4]); ctx.beginPath(); if (brick.movementType === 'vertical') { const y1 = initialCenterY - range; const y2 = initialCenterY + range; ctx.moveTo(initialCenterX, y1); ctx.lineTo(initialCenterX, y2); ctx.moveTo(initialCenterX - 5, y1); ctx.lineTo(initialCenterX + 5, y1); ctx.moveTo(initialCenterX - 5, y2); ctx.lineTo(initialCenterX + 5, y2); } else { const x1 = initialCenterX - range; const x2 = initialCenterX + range; ctx.moveTo(x1, initialCenterY); ctx.lineTo(x2, initialCenterY); ctx.moveTo(x1, initialCenterY - 5); ctx.lineTo(x1, initialCenterY + 5); ctx.moveTo(x2, initialCenterY - 5); ctx.lineTo(x2, initialCenterY + 5); } ctx.stroke(); ctx.restore(); }, drawHandles: (brick) => { const handles = utils.getBrickHandles(brick); ctx.fillStyle = HANDLE_COLOR; for (const type of ['tl', 'tr', 'bl', 'br']) { ctx.beginPath(); ctx.arc(handles[type].x, handles[type].y, HANDLE_SIZE, 0, Math.PI * 2); ctx.fill(); } ctx.beginPath(); ctx.arc(handles.rotate.x, handles.rotate.y, HANDLE_SIZE * ROTATE_HANDLE_SIZE_FACTOR, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(handles.center.x, handles.center.y); ctx.lineTo(handles.rotate.x, handles.rotate.y); ctx.strokeStyle = HANDLE_COLOR; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]); } };

    // --- Editor Logic --- (No Changes except handlePropertyChange added previously)
    const editor = { resetSelectionAndHistory: () => { editorState.selectedItems = []; editor.resetSelectionAndDragging(); editorState.history = []; editorState.historyIndex = -1; uiManager.updateBrickPropertiesUI(); }, resetSelectionAndDragging: () => { editorState.draggingHandle = null; editorState.isDraggingSelection = false; editorState.isMarqueeSelecting = false; editorState.originalItemStates = []; uiManager.updateMarqueeBox(); uiManager.updateCursorStyle(editorState.mouse.x, editorState.mouse.y); }, addBrick: (type = 'static') => { if (gameState.mode !== 'editor' || !editorState.contextMenuTarget || editorState.contextMenuTarget.type !== 'empty') return; historyManager.saveState(); const x = editorState.contextMenuTarget.x || editorState.mouse.x; const y = editorState.contextMenuTarget.y || editorState.mouse.y; const width = 100; const height = 20; const initialX = x - width / 2; const initialY = y - height / 2; const newBrick = { x: initialX, y: initialY, width: width, height: height, angle: 0, isKillBrick: type === 'kill', movementType: (type === 'vertical' || type === 'horizontal') ? type : null, moveRange: DEFAULT_MOVE_RANGE, moveSpeed: DEFAULT_MOVE_SPEED, initialX: initialX, initialY: initialY }; gameState.bricks.push(newBrick); editorState.selectedItems = [{ type: 'brick', index: gameState.bricks.length - 1 }]; editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, toggleKillBrick: (index) => { if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return; historyManager.saveState(); const brick = gameState.bricks[index]; brick.isKillBrick = !brick.isKillBrick; editor.ensureItemSelected({ type: 'brick', index: index }); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, setMovementType: (index, type) => { if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return; historyManager.saveState(); const brick = gameState.bricks[index]; if (type === null) { brick.movementType = null; if (brick.initialX !== undefined) brick.x = brick.initialX; if (brick.initialY !== undefined) brick.y = brick.initialY; } else { if (brick.movementType !== type || brick.initialX === undefined || brick.initialY === undefined) { brick.initialX = brick.x; brick.initialY = brick.y; } brick.movementType = type; brick.moveRange = brick.moveRange ?? DEFAULT_MOVE_RANGE; brick.moveSpeed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED; } editor.ensureItemSelected({ type: 'brick', index: index }); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, deleteSingleBrick: (index) => { if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return; historyManager.saveState(); gameState.bricks.splice(index, 1); editorState.selectedItems = editorState.selectedItems .filter(item => !(item.type === 'brick' && item.index === index)) .map(item => { if (item.type === 'brick' && item.index > index) { item.index--; } return item; }); editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, deleteSelectedItems: () => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0) return; historyManager.saveState(); const brickIndicesToDelete = editorState.selectedItems .filter(item => item.type === 'brick') .map(item => item.index) .sort((a, b) => b - a); const deletedPlayer = editorState.selectedItems.some(item => item.type === 'player'); const deletedHole = editorState.selectedItems.some(item => item.type === 'hole'); brickIndicesToDelete.forEach(index => { if (index >= 0 && index < gameState.bricks.length) { gameState.bricks.splice(index, 1); } else { console.warn("Attempted to delete invalid brick index:", index); } }); if (deletedPlayer || deletedHole) { uiManager.showMessage("Player and Hole cannot be deleted.", 1500); } editorState.selectedItems = []; editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, handleCopy: () => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0) return; editorState.clipboard = []; editorState.selectedItems.forEach(item => { if (item.type === 'brick') { editorState.clipboard.push(utils.deepClone(gameState.bricks[item.index])); } }); uiManager.showMessage(`Copied ${editorState.clipboard.length} brick(s).`, 1000); }, handlePaste: () => { if (gameState.mode !== 'editor' || editorState.clipboard.length === 0) return; historyManager.saveState(); const newSelection = []; editorState.clipboard.forEach(itemData => { if (itemData) { const newItem = utils.deepClone(itemData); newItem.x += PASTE_OFFSET; newItem.y += PASTE_OFFSET; newItem.initialX = (newItem.initialX !== undefined ? newItem.initialX : newItem.x - PASTE_OFFSET) + PASTE_OFFSET; newItem.initialY = (newItem.initialY !== undefined ? newItem.initialY : newItem.y - PASTE_OFFSET) + PASTE_OFFSET; gameState.bricks.push(newItem); newSelection.push({ type: 'brick', index: gameState.bricks.length - 1 }); } }); editorState.selectedItems = newSelection; editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, handleNudge: (dx, dy) => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0 || (dx === 0 && dy === 0)) return; if (!editorState.isNudging) { historyManager.saveState(); editorState.isNudging = true; } editorState.selectedItems.forEach(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; brick.x += dx; brick.y += dy; brick.initialX += dx; brick.initialY += dy; } else if (item.type === 'player') { gameState.player.x += dx; gameState.player.y += dy; if (gameState.ball.onPlayer) gameLogic.resetBallPosition(); } else if (item.type === 'hole') { gameState.hole.x += dx; gameState.hole.y += dy; } }); drawing.draw(); }, selectItem: (itemToSelect, ctrlPressed) => { if (!itemToSelect) return; const alreadySelected = editorState.selectedItems.some(sel => sel.type === itemToSelect.type && sel.index === itemToSelect.index); if (ctrlPressed) { if (alreadySelected) { editorState.selectedItems = editorState.selectedItems.filter(sel => !(sel.type === itemToSelect.type && sel.index === itemToSelect.index)); } else { editorState.selectedItems.push(itemToSelect); } } else { if (!alreadySelected) { editorState.selectedItems = [itemToSelect]; } } uiManager.updateBrickPropertiesUI(); }, ensureItemSelected: (itemToSelect) => { if (!editorState.selectedItems.some(sel => sel.type === itemToSelect.type && sel.index === itemToSelect.index)) { editorState.selectedItems.push(itemToSelect); uiManager.updateBrickPropertiesUI(); } }, getItemAtPoint: (px, py) => { for (let i = gameState.bricks.length - 1; i >= 0; i--) { if (utils.isPointInRotatedRect(px, py, gameState.bricks[i])) { return { type: 'brick', index: i }; } } const playerRect = { x: gameState.player.x, y: gameState.player.y, width: gameState.player.width, height: gameState.player.height }; const headCenter = { x: gameState.player.x + gameState.player.width / 2, y: gameState.player.y - PLAYER_HEAD_RADIUS }; if ((Math.hypot(px - headCenter.x, py - headCenter.y) <= PLAYER_HEAD_RADIUS) || (px >= playerRect.x && px <= playerRect.x + playerRect.width && py >= playerRect.y && py <= playerRect.y + playerRect.height)) { return { type: 'player', index: null }; } if (Math.hypot(px - gameState.hole.x, py - gameState.hole.y) <= gameState.hole.radius) { return { type: 'hole', index: null }; } return null; }, isPointOverSelection: (px, py) => { return editorState.selectedItems.some(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; return brick && utils.isPointInRotatedRect(px, py, brick); } else if (item.type === 'player') { const playerRect = { x: gameState.player.x, y: gameState.player.y, width: gameState.player.width, height: gameState.player.height }; const headCenter = { x: gameState.player.x + gameState.player.width / 2, y: gameState.player.y - PLAYER_HEAD_RADIUS }; return (Math.hypot(px - headCenter.x, py - headCenter.y) <= PLAYER_HEAD_RADIUS) || (px >= playerRect.x && px <= playerRect.x + playerRect.width && py >= playerRect.y && py <= playerRect.y + playerRect.height); } else if (item.type === 'hole') { return Math.hypot(px - gameState.hole.x, py - gameState.hole.y) <= gameState.hole.radius; } return false; }); }, getHandleAtPoint: (px, py) => { if (editorState.selectedItems.length !== 1 || editorState.selectedItems[0].type !== 'brick') { return null; } const brick = gameState.bricks[editorState.selectedItems[0].index]; if (!brick) return null; const handles = utils.getBrickHandles(brick); if (Math.hypot(px - handles.rotate.x, py - handles.rotate.y) <= HANDLE_SIZE * 1.5) { return { type: 'rotate', itemRef: editorState.selectedItems[0], startBrickState: utils.deepClone(brick) }; } for (const type of ['tl', 'tr', 'bl', 'br']) { if (Math.hypot(px - handles[type].x, py - handles[type].y) <= HANDLE_SIZE * 1.2) { return { type: type, itemRef: editorState.selectedItems[0], startBrickState: utils.deepClone(brick) }; } } return null; }, finalizeMarqueeSelection: (ctrlPressed) => { const marqueeRect = { x: Math.min(editorState.marqueeStart.x, editorState.marqueeEnd.x), y: Math.min(editorState.marqueeStart.y, editorState.marqueeEnd.y), width: Math.abs(editorState.marqueeStart.x - editorState.marqueeEnd.x), height: Math.abs(editorState.marqueeStart.y - editorState.marqueeEnd.y) }; if (marqueeRect.width < 5 && marqueeRect.height < 5) { if (!ctrlPressed) { editorState.selectedItems = []; } uiManager.updateBrickPropertiesUI(); return; } const newlySelected = []; gameState.bricks.forEach((brick, index) => { const brickBounds = utils.getRectBoundingBox(brick); if (utils.doRectsOverlap(marqueeRect, brickBounds)) { newlySelected.push({ type: 'brick', index: index }); } }); const playerBounds = { x: gameState.player.x, y: gameState.player.y - PLAYER_HEAD_RADIUS * 2, width: gameState.player.width, height: gameState.player.height + PLAYER_HEAD_RADIUS * 2 }; if (utils.doRectsOverlap(marqueeRect, playerBounds)) { newlySelected.push({ type: 'player', index: null }); } const holeBounds = { x: gameState.hole.x - gameState.hole.radius, y: gameState.hole.y - gameState.hole.radius, width: gameState.hole.radius * 2, height: gameState.hole.radius * 2 }; if (utils.doRectsOverlap(marqueeRect, holeBounds)) { newlySelected.push({ type: 'hole', index: null }); } if (ctrlPressed) { newlySelected.forEach(newItem => { if (!editorState.selectedItems.some(sel => sel.type === newItem.type && sel.index === newItem.index)) { editorState.selectedItems.push(newItem); } }); } else { editorState.selectedItems = newlySelected; } uiManager.updateBrickPropertiesUI(); }, updateItemsDuringDrag: (dx, dy) => { editorState.selectedItems.forEach((item, i) => { const origState = editorState.originalItemStates[i]; if (!origState) return; if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (!brick) return; brick.x = origState.x + dx; brick.y = origState.y + dy; } else if (item.type === 'player') { gameState.player.x = origState.x + dx; gameState.player.y = origState.y + dy; if (gameState.ball.onPlayer) gameLogic.resetBallPosition(); } else if (item.type === 'hole') { gameState.hole.x = origState.x + dx; gameState.hole.y = origState.y + dy; } }); }, updateBrickDuringResize: (handleType, currentMouseX, currentMouseY) => { if (!editorState.draggingHandle || !editorState.draggingHandle.itemRef || editorState.draggingHandle.startBrickState === undefined) return; const brickIndex = editorState.draggingHandle.itemRef.index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; const origState = editorState.draggingHandle.startBrickState; const origAngle = origState.angle || 0; const cosA = Math.cos(-origAngle); const sinA = Math.sin(-origAngle); const ocx = origState.x + origState.width / 2; const ocy = origState.y + origState.height / 2; const dxWorld = currentMouseX - ocx; const dyWorld = currentMouseY - ocy; const localMx = dxWorld * cosA - dyWorld * sinA; const localMy = dxWorld * sinA + dyWorld * cosA; let newHalfWidth, newHalfHeight; switch (handleType) { case 'br': newHalfWidth = localMx; newHalfHeight = localMy; break; case 'bl': newHalfWidth = -localMx; newHalfHeight = localMy; break; case 'tr': newHalfWidth = localMx; newHalfHeight = -localMy; break; case 'tl': newHalfWidth = -localMx; newHalfHeight = -localMy; break; default: return; } newHalfWidth = Math.max(MIN_BRICK_DIMENSION / 2, newHalfWidth); newHalfHeight = Math.max(MIN_BRICK_DIMENSION / 2, newHalfHeight); const newWidth = 2 * newHalfWidth; const newHeight = 2 * newHalfHeight; const centerShiftXLocal = (newWidth - origState.width) / 2; const centerShiftYLocal = (newHeight - origState.height) / 2; let shiftFactorX = 0, shiftFactorY = 0; switch(handleType) { case 'tl': shiftFactorX = -1; shiftFactorY = -1; break; case 'tr': shiftFactorX = 1; shiftFactorY = -1; break; case 'bl': shiftFactorX = -1; shiftFactorY = 1; break; case 'br': shiftFactorX = 1; shiftFactorY = 1; break; } const finalShiftLocalX = centerShiftXLocal * shiftFactorX; const finalShiftLocalY = centerShiftYLocal * shiftFactorY; const cosARot = Math.cos(origAngle); const sinARot = Math.sin(origAngle); const centerShiftWorldX = finalShiftLocalX * cosARot - finalShiftLocalY * sinARot; const centerShiftWorldY = finalShiftLocalX * sinARot + finalShiftLocalY * cosARot; const newCx = ocx + centerShiftWorldX; const newCy = ocy + centerShiftWorldY; brick.width = newWidth; brick.height = newHeight; brick.angle = origAngle; const localTLX = -newWidth / 2; const localTLY = -newHeight / 2; brick.x = newCx + (localTLX * cosARot - localTLY * sinARot); brick.y = newCy + (localTLX * sinARot + localTLY * cosARot); }, updateBrickDuringRotate: (currentMouseX, currentMouseY) => { if (!editorState.draggingHandle || !editorState.draggingHandle.itemRef || editorState.draggingHandle.startBrickState === undefined) return; const brickIndex = editorState.draggingHandle.itemRef.index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; const origState = editorState.draggingHandle.startBrickState; const center = utils.getBrickHandles(origState).center; const currentAngle = Math.atan2(currentMouseY - center.y, currentMouseX - center.x); const startAngle = Math.atan2(editorState.dragStart.y - center.y, editorState.dragStart.x - center.x); brick.angle = origState.angle + (currentAngle - startAngle); }, finalizeItemManipulation: () => { if (editorState.draggingHandle || editorState.isDraggingSelection) { editorState.selectedItems.forEach(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (!brick) return; brick.initialX = brick.x; brick.initialY = brick.y; } }); const previousState = editorState.history[editorState.historyIndex]; const currentState = historyManager.getCurrentStateSnapshot(); if (previousState && utils.statesAreEqual(previousState, currentState)) { editorState.history.pop(); editorState.historyIndex--; } else { if (editorState.historyIndex >= 0 && editorState.history.length > editorState.historyIndex) { editorState.history[editorState.historyIndex] = currentState; } else { console.warn("History index issue during finalization."); historyManager.saveState(true); } } } }, handlePropertyChange: (event) => { if (editorState.selectedItems.length !== 1 || editorState.selectedItems[0].type !== 'brick') { return; } const brickIndex = editorState.selectedItems[0].index; if (brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; const propertyName = event.target.name; const value = parseFloat(event.target.value); if (isNaN(value) || value < 0) { console.warn(`Invalid value entered for ${propertyName}:`, event.target.value); event.target.value = brick[propertyName] ?? (propertyName === 'moveRange' ? DEFAULT_MOVE_RANGE : DEFAULT_MOVE_SPEED); return; } if (brick[propertyName] === value) { return; } historyManager.saveState(); brick[propertyName] = value; editorState.isUpdatingPropertiesFromInput = true; drawing.draw(); editorState.isUpdatingPropertiesFromInput = false; } };

    // --- Event Handlers --- (No Changes)
    const eventHandlers = { handleResize: () => { utils.resizeCanvas(); }, handleContextMenu: (e) => { e.preventDefault(); uiManager.hideContextMenu(); if (gameState.mode !== 'editor' || uiManager.isPointerOverUI(e.clientX, e.clientY)) { return; } const mx = e.clientX; const my = e.clientY; let targetItem = editor.getItemAtPoint(mx, my); let targetType = 'empty'; let targetIndex = null; if (targetItem) { targetType = targetItem.type; targetIndex = targetItem.index; if (!editorState.selectedItems.some(sel => sel.type === targetType && sel.index === targetIndex)) { editorState.selectedItems = [targetItem]; uiManager.updateBrickPropertiesUI(); drawing.draw(); } } editorState.contextMenuTarget = { type: targetType, index: targetIndex, x: mx, y: my }; uiManager.showContextMenu(mx, my); }, handleMouseDown: (e) => { if (e.button !== 0 || uiManager.isPointerOverUI(e.clientX, e.clientY)) { return; } editorState.mouse.down = true; editorState.mouse.x = e.clientX; editorState.mouse.y = e.clientY; editorState.mouse.dragStartX = editorState.mouse.x; editorState.mouse.dragStartY = editorState.mouse.y; uiManager.hideContextMenu(); editor.resetSelectionAndDragging(); if (gameState.mode === 'editor') { const mx = editorState.mouse.x; const my = editorState.mouse.y; const ctrlPressed = e.ctrlKey || e.metaKey; const clickedHandle = editor.getHandleAtPoint(mx, my); if (clickedHandle) { editorState.draggingHandle = clickedHandle; editorState.dragStart = { x: mx, y: my }; historyManager.saveState(); canvas.style.cursor = clickedHandle.type === 'rotate' ? 'grabbing' : (clickedHandle.type === 'tl' || clickedHandle.type === 'br') ? 'nwse-resize' : 'nesw-resize'; } else { const clickedItem = editor.getItemAtPoint(mx, my); if (clickedItem) { const isClickOnSelection = editor.isPointOverSelection(mx, my); editor.selectItem(clickedItem, ctrlPressed); if (editor.isPointOverSelection(mx, my)) { editorState.isDraggingSelection = true; editorState.dragStart = { x: mx, y: my }; editorState.originalItemStates = editorState.selectedItems.map(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; return brick ? utils.deepClone(brick) : null; } if (item.type === 'player') return utils.deepClone(gameState.player); if (item.type === 'hole') return utils.deepClone(gameState.hole); return null; }).filter(s => s !== null); historyManager.saveState(); canvas.style.cursor = 'move'; } } else { if (!ctrlPressed) { editorState.selectedItems = []; uiManager.updateBrickPropertiesUI(); } editorState.isMarqueeSelecting = true; editorState.marqueeStart = { x: mx, y: my }; editorState.marqueeEnd = { x: mx, y: my }; uiManager.updateMarqueeBox(); canvas.style.cursor = 'crosshair'; } } drawing.draw(); } else { if (gameState.ball.onPlayer) { editorState.aim.active = true; eventHandlers.updateAim(editorState.mouse.x, editorState.mouse.y); drawing.draw(); } } }, handleMouseMove: (e) => { editorState.mouse.x = e.clientX; editorState.mouse.y = e.clientY; const mx = editorState.mouse.x; const my = editorState.mouse.y; if (gameState.mode === 'editor') { if (editorState.mouse.down) { const dx = mx - editorState.dragStart.x; const dy = my - editorState.dragStart.y; if (editorState.draggingHandle) { editorState.isDraggingSelection = false; editorState.isMarqueeSelecting = false; const handleType = editorState.draggingHandle.type; if (handleType === 'rotate') { editor.updateBrickDuringRotate(mx, my); canvas.style.cursor = 'grabbing'; } else { editor.updateBrickDuringResize(handleType, mx, my); } drawing.draw(); } else if (editorState.isDraggingSelection) { editorState.isMarqueeSelecting = false; canvas.style.cursor = 'move'; editor.updateItemsDuringDrag(dx, dy); drawing.draw(); } else if (editorState.isMarqueeSelecting) { canvas.style.cursor = 'crosshair'; editorState.marqueeEnd = { x: mx, y: my }; uiManager.updateMarqueeBox(); } } else { uiManager.updateCursorStyle(mx, my); } } else { if (editorState.aim.active && gameState.ball.onPlayer) { eventHandlers.updateAim(mx, my); drawing.draw(); } } }, handleMouseUp: (e) => { if (e.button !== 0 || !editorState.mouse.down) return; editorState.mouse.down = false; if (gameState.mode === 'editor') { editor.finalizeItemManipulation(); if (editorState.isMarqueeSelecting) { editor.finalizeMarqueeSelection(e.ctrlKey || e.metaKey); } const dx = editorState.mouse.x - editorState.mouse.dragStartX; const dy = editorState.mouse.y - editorState.mouse.dragStartY; if (!editorState.draggingHandle && !editorState.isDraggingSelection && !editorState.isMarqueeSelecting) { if (Vec.lenSq({x: dx, y: dy}) < CLICK_THRESHOLD_SQ) { /* Simple click */ } } editor.resetSelectionAndDragging(); drawing.draw(); } else { if (editorState.aim.active && gameState.ball.onPlayer) { gameLogic.fireBall(); editorState.aim.active = false; drawing.draw(); } } uiManager.updateCursorStyle(e.clientX, e.clientY); }, handleKeyDown: (e) => { if (gameState.mode !== 'editor') return; const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA'); const ctrlPressed = e.ctrlKey || e.metaKey; if (isInputFocused) { if (activeEl.type === 'number' && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Tab"].includes(e.key)) { return; } if (!(ctrlPressed && (e.key.toLowerCase() === 'c' || e.key.toLowerCase() === 'v' || e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'x'))) { /* Block other shortcuts? Maybe only block delete/backspace/arrows? */ if (["Delete", "Backspace", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) { /* Allow text deletion/navigation within input */ } else if (ctrlPressed && e.key.toLowerCase() === 'z') { /* Allow undo/redo in inputs? Maybe not */ return; } else if (ctrlPressed && e.key.toLowerCase() === 'y') { return; } else if (!ctrlPressed && e.key.length === 1) { /* Allow typing */ } else { /* Block other potential editor shortcuts */ return; } } } if (ctrlPressed && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) { historyManager.redo(); } else { historyManager.undo(); } return; } if (ctrlPressed && e.key.toLowerCase() === 'y') { e.preventDefault(); historyManager.redo(); return; } if (ctrlPressed && e.key.toLowerCase() === 'c') { e.preventDefault(); editor.handleCopy(); return; } if (ctrlPressed && e.key.toLowerCase() === 'v') { e.preventDefault(); editor.handlePaste(); return; } if ((e.key === "Delete" || e.key === "Backspace") && editorState.selectedItems.length > 0 && !isInputFocused) { e.preventDefault(); editor.deleteSelectedItems(); return; } let dx = 0, dy = 0; switch (e.key) { case "ArrowUp": dy = -NUDGE_AMOUNT; break; case "ArrowDown": dy = NUDGE_AMOUNT; break; case "ArrowLeft": dx = -NUDGE_AMOUNT; break; case "ArrowRight": dx = NUDGE_AMOUNT; break; default: return; } if ((dx !== 0 || dy !== 0) && !isInputFocused) { e.preventDefault(); editor.handleNudge(dx, dy); } }, handleKeyUp: (e) => { if (gameState.mode !== 'editor') return; if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) { if (editorState.isNudging) { editorState.isNudging = false; } } }, updateAim: (mx, my) => { if (!gameState.ball.onPlayer) return; const aimVecRaw = Vec.sub({ x: mx, y: my }, { x: gameState.ball.x, y: gameState.ball.y }); let aimPowerLength = Vec.len(aimVecRaw); aimPowerLength = Math.min(aimPowerLength, AIM_LINE_LENGTH); const power = aimPowerLength / AIM_POWER_FACTOR; const normAimVec = Vec.normalize(aimVecRaw); editorState.aim.dx = normAimVec.x * power; editorState.aim.dy = normAimVec.y * power; if (editorState.aim.dy > MIN_AIM_VY) { editorState.aim.dy = MIN_AIM_VY; } } };

    // --- Game Loop ---
    let lastTimestamp = 0;
    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTimestamp) / 1000; // Delta time in seconds
        lastTimestamp = timestamp;

        gameLogic.update(deltaTime); // Pass deltaTime if needed for physics
        drawing.draw();

        requestAnimationFrame(gameLoop);
    }

    // --- Initialization ---
    async function init() {
        console.log("Initializing Bounce Back..."); // *** MODIFIED: Game Name ***
        // Setup Event Listeners
        window.addEventListener("resize", eventHandlers.handleResize);
        canvas.addEventListener("contextmenu", eventHandlers.handleContextMenu);
        canvas.addEventListener("mousedown", eventHandlers.handleMouseDown);
        canvas.addEventListener("mousemove", eventHandlers.handleMouseMove);
        canvas.addEventListener("mouseup", eventHandlers.handleMouseUp);
        canvas.addEventListener("mouseleave", () => {
            if (editorState.mouse.down) {
                 eventHandlers.handleMouseUp({ button: 0, clientX: editorState.mouse.x, clientY: editorState.mouse.y });
            }
            editorState.aim.active = false;
        });
        document.addEventListener("keydown", eventHandlers.handleKeyDown);
        document.addEventListener("keyup", eventHandlers.handleKeyUp);

        // Setup Button Listeners
        playButton.onclick = gameLogic.startGame;
        editorButton.onclick = gameLogic.switchToEditorMode;
        showMenuButton.onclick = uiManager.showMenu;

        // Setup Property Input Listeners
        propMoveRangeInput.addEventListener('input', editor.handlePropertyChange);
        propMoveSpeedInput.addEventListener('input', editor.handlePropertyChange);


        // Load data (awaiting the async function)
        await levelManager.loadLevelsFromStorage(); // Wait for levels to load from storage or fetch

        // Set initial state based on loaded levels
        utils.resizeCanvas(); // Initial resize sets canvas size and calls loadLevelData for index 0

        // *** MODIFIED: Start in Play Mode with Menu Hidden ***
        gameLogic.startGame(); // Start in play mode
        uiManager.hideMenu(); // Start with menu hidden

        // Start the game loop
        lastTimestamp = performance.now();
        requestAnimationFrame(gameLoop);
        console.log("Initialization Complete.");
    }

    // --- Start the application ---
    init();

</script>

</body>
</html>
