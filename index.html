<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bounce Back - Level Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; user-select: none; /* Prevent text selection during drag */ }
        canvas { display: block; background: #f0f8ff; /* Alice Blue */ }
        #gameCanvas.hidden, #menu.initially-hidden { display: none; }

        #startMenu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(200, 220, 255, 0.95); /* Light blueish overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30; /* Ensure it's on top */
            text-align: center;
            padding: 20px;
        }
        #startMenu.hidden { display: none; }
        #startMenu h1 { font-size: 3rem; font-weight: 700; color: #1e3a8a; /* Dark blue */ margin-bottom: 1rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
        #startMenu button {
            padding: 0.75rem 2rem;
            font-size: 1.25rem;
            font-weight: 500;
            color: white;
            background-color: #2563eb; /* bg-blue-600 */
            border: none;
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #startMenu button:hover { background-color: #1d4ed8; /* hover:bg-blue-700 */ }
        #startMenu button:active { transform: scale(0.98); }

        #contextMenu { position: absolute; display: none; z-index: 10; background-color: white; border-radius: 0.375rem; /* rounded-md */ box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */ border: 1px solid #e5e7eb; /* border-gray-200 */ padding: 0.25rem; /* p-1 */ min-width: 180px; }
        #contextMenu button { display: block; width: 100%; text-align: left; padding: 0.5rem 1rem; /* px-4 py-2 */ font-size: 0.875rem; /* text-sm */ color: #374151; /* text-gray-700 */ border-radius: 0.25rem; /* rounded-sm */ background: none; border: none; cursor: pointer; }
        #contextMenu button:hover { background-color: #f3f4f6; /* hover:bg-gray-100 */ }
        #messageBox { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.75); color: white; padding: 20px 30px; border-radius: 10px; text-align: center; z-index: 20; display: none; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        #messageBox button { margin-top: 1rem; padding: 0.5rem 1rem; background-color: #3b82f6; /* bg-blue-500 */ color: white; border: none; border-radius: 0.375rem; /* rounded-md */ cursor: pointer; transition: background-color 0.15s ease-in-out; }
        #messageBox button:hover { background-color: #2563eb; /* hover:bg-blue-600 */ }
        /* Cursors */
        .cursor-grab { cursor: grab; } .cursor-grabbing { cursor: grabbing; } .cursor-move { cursor: move; } .cursor-crosshair { cursor: crosshair; } .cursor-nwse-resize { cursor: nwse-resize; } .cursor-nesw-resize { cursor: nesw-resize; }
        /* Level List Styling */
        #levelList li { padding: 4px 8px; cursor: pointer; border-radius: 4px; margin-bottom: 2px; border: 1px solid transparent; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.1s ease, border-color 0.1s ease; }
        #levelList li:hover { background-color: #f0f0f0; border-color: #ddd; }
        #levelList li.selected { background-color: #dbeafe; /* blue-100 */ border-color: #93c5fd; /* blue-300 */ font-weight: 500; }
        #levelList li .level-name { flex-grow: 1; margin-right: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: text; /* Indicate renamable */ }
        #levelList li .level-name:hover { text-decoration: underline; } /* Indicate renamable on hover */
        #levelList li .level-controls button { padding: 2px 4px; margin-left: 4px; font-size: 0.75rem; line-height: 1; border-radius: 4px; background-color: #e5e7eb; /* gray-200 */ color: #374151; /* gray-700 */ border: none; cursor: pointer; transition: background-color 0.1s ease; }
        #levelList li .level-controls button:hover:not(:disabled) { background-color: #d1d5db; /* gray-300 */ }
        #levelList li .level-controls button:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Marquee Selection Box */
        #marqueeBox { position: absolute; border: 1px dashed #007bff; background-color: rgba(0, 123, 255, 0.1); display: none; z-index: 5; pointer-events: none; /* Prevent interaction */ }
        /* Editor Controls & Properties Section */
        #editorControls, #brickProperties { border-top: 1px solid #e5e7eb; /* border-gray-200 */ padding-top: 0.75rem; margin-top: 0.75rem; }
        #brickProperties label { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; /* text-sm */ color: #4b5563; /* text-gray-600 */ }
        #brickProperties input[type="number"] { width: 100%; padding: 0.3rem 0.5rem; border: 1px solid #d1d5db; /* border-gray-300 */ border-radius: 0.25rem; /* rounded-sm */ font-size: 0.875rem; /* text-sm */ margin-bottom: 0.5rem; }
        #brickProperties input[type="number"]:disabled { background-color: #f3f4f6; /* bg-gray-100 */ cursor: not-allowed; opacity: 0.7; }
        /* Menu Styling */
        #menu { transition: transform 0.3s ease-out; }
        #menu.hidden { transform: translateX(-110%); }
        #showMenuButton { transition: opacity 0.3s ease-in-out; }
        #showMenuButton.hidden { opacity: 0; pointer-events: none; }
        /* Logo Placeholder Style */
        #logoPlaceholder { display: inline-block; background-color: #e0e0e0; color: #757575; text-align: center; line-height: 4rem; /* Adjust based on height */ font-size: 0.8rem; }

    </style>
</head>
<body class="bg-gray-100">

<div id="startMenu">
    <h1>Bounce Back</h1>
    <button id="startGameButton">Play Game</button>
</div>

<button id="showMenuButton" class="absolute top-4 left-4 bg-gray-600 text-white p-2 rounded-md hover:bg-gray-700 transition duration-150 ease-in-out z-20 hidden">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"> <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" /> </svg>
</button>

<div id="menu" class="absolute top-4 left-4 bg-white p-4 rounded-lg shadow-xl z-10 space-y-3 w-64 max-h-[calc(100vh-2rem)] overflow-y-auto initially-hidden">
    <div class="flex justify-center mb-2">
        <img id="gameLogo" src="logo.png" alt="Bounce Back Logo" class="w-20 h-auto rounded" onerror="this.style.display='none'; document.getElementById('logoPlaceholder').style.display='inline-block';">
    </div>
    <h2 class="text-xl font-semibold text-center text-gray-800">Bounce Back</h2>

    <div class="grid grid-cols-2 gap-2">
        <button id="playButton" class="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition duration-150 ease-in-out text-sm font-medium">Play Mode</button>
        <button id="editorButton" class="w-full px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition duration-150 ease-in-out text-sm font-medium">Level Editor</button>
    </div>

    <div class="text-sm text-gray-600 text-center">Playing Level: <span id="levelDisplay" class="font-medium">1</span></div>

    <div id="editorControls" class="hidden space-y-3">
        <h3 class="text-md font-semibold text-center text-gray-700">Level Editor</h3>
        <div class="text-sm text-gray-600 text-center">Editing Level: <span id="editingLevelDisplay" class="font-medium">1</span></div>
        <div class="text-xs text-gray-500 text-center mb-2 p-1 bg-gray-50 rounded border border-gray-200">
            Dbl-Click Name: Rename | Ctrl+Click: Multi-Select | Drag: Marquee | Arrow Keys: Nudge | Ctrl+C/V/Z/Y/Del
        </div>

        <div class="border rounded-md p-2 bg-gray-50 shadow-inner">
            <h4 class="text-sm font-medium mb-1 text-gray-700">Levels:</h4>
            <ul id="levelList" class="text-sm max-h-48 overflow-y-auto mb-2 border rounded bg-white"></ul>
            <div class="grid grid-cols-2 gap-1 mt-2">
                 <button onclick="levelManager.addNew()" class="w-full px-3 py-1 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition duration-150 ease-in-out text-xs">Add New</button>
                 <button onclick="levelManager.importLevels()" class="w-full px-3 py-1 bg-cyan-500 text-white rounded-md hover:bg-cyan-600 transition duration-150 ease-in-out text-xs">Import</button>
                 <button onclick="levelManager.deleteSelected()" class="w-full px-3 py-1 bg-red-500 text-white rounded-md hover:bg-red-600 transition duration-150 ease-in-out text-xs">Delete Sel.</button>
                 <button onclick="levelManager.exportSelected()" class="w-full px-3 py-1 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition duration-150 ease-in-out text-xs">Export Sel.</button>
            </div>
             <input type="file" id="importFile" accept=".json" multiple style="display: none;" onchange="levelManager.handleFileImport(event)">
        </div>
        <button onclick="levelManager.saveCurrentLevel()" id="saveButton" class="w-full px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 transition duration-150 ease-in-out text-sm font-medium">Save Current Level</button>

        <div id="brickProperties" class="hidden space-y-2">
             <h4 class="text-sm font-medium text-center text-gray-700">Brick Properties</h4>
             <div>
                 <label for="propMoveRange">Move Range:</label>
                 <input type="number" id="propMoveRange" name="moveRange" min="0" step="1">
             </div>
             <div>
                 <label for="propMoveSpeed">Move Speed:</label>
                 <input type="number" id="propMoveSpeed" name="moveSpeed" min="0" step="0.1">
             </div>
        </div>
        </div>

    <hr class="mt-4">
    <button onclick="uiManager.hideMenu()" class="w-full mt-2 px-4 py-1 bg-gray-400 text-white rounded-md hover:bg-gray-500 transition duration-150 ease-in-out text-sm">Hide Menu</button>
</div>

<div id="contextMenu"></div>

<div id="messageBox">
    <p id="messageText"></p>
    <button onclick="uiManager.hideMessage()">OK</button>
</div>

<div id="marqueeBox"></div>

<canvas id="gameCanvas" class="hidden"></canvas>

<script>
    // --- DOM Element References ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const menuDiv = document.getElementById("menu");
    const showMenuButton = document.getElementById("showMenuButton");
    const editorControlsDiv = document.getElementById("editorControls");
    const contextMenuDiv = document.getElementById("contextMenu");
    const playButton = document.getElementById("playButton");
    const editorButton = document.getElementById("editorButton");
    const saveButton = document.getElementById("saveButton");
    const levelDisplay = document.getElementById("levelDisplay");
    const editingLevelDisplay = document.getElementById("editingLevelDisplay");
    const levelListElement = document.getElementById("levelList");
    const messageBox = document.getElementById("messageBox");
    const messageText = document.getElementById("messageText");
    const marqueeBox = document.getElementById("marqueeBox");
    const importFileInput = document.getElementById("importFile");
    const brickPropertiesDiv = document.getElementById("brickProperties");
    const propMoveRangeInput = document.getElementById("propMoveRange");
    const propMoveSpeedInput = document.getElementById("propMoveSpeed");
    const startMenu = document.getElementById("startMenu");
    const startGameButton = document.getElementById("startGameButton");


    // --- Base Game Constants (Unscaled) ---
    const BASE_PLAYER_WIDTH = 40;
    const BASE_PLAYER_HEIGHT = 10;
    const BASE_PLAYER_HEAD_RADIUS = 10;
    const BASE_BALL_RADIUS = 10;
    const BASE_HOLE_RADIUS = 15;
    const BASE_AIM_LINE_LENGTH = 100;
    const AIM_POWER_FACTOR = 10.0;
    const AIM_VISUAL_SCALE = 5;
    const MIN_AIM_VY = -0.1;
    const BASE_HANDLE_SIZE = 5;
    const BASE_ROTATE_HANDLE_OFFSET = 20;
    const ROTATE_HANDLE_SIZE_FACTOR = 1.2;
    const BASE_MIN_BRICK_DIMENSION = 10;
    const COLLISION_PUSH_FACTOR = 1.01;
    const BASE_PLAYER_DEFAULT_BOTTOM_OFFSET = 60;
    const BASE_HOLE_DEFAULT_Y = 100;
    const BASE_BALL_OUTLINE_WIDTH = 2;
    const NUDGE_AMOUNT = 1;
    const PASTE_OFFSET = 15;
    const MAX_HISTORY = 50;
    const MESSAGE_DISPLAY_TIME = 1500;
    const BASE_DEFAULT_MOVE_RANGE = 50;
    const DEFAULT_MOVE_SPEED = 1.0;
    const CLICK_THRESHOLD_SQ = 9;

    // --- Colors ---
    const BRICK_COLOR = "#6B7280";
    const BRICK_STROKE_COLOR = "#1F2937";
    const KILL_BRICK_COLOR = "#EF4444";
    const VERTICAL_MOVER_COLOR = "#FACC15";
    const HORIZONTAL_MOVER_COLOR = "#4ADE80";
    const SELECTED_BRICK_COLOR = "#3B82F6";
    const SELECTED_ITEM_OUTLINE_COLOR = "#F59E0B";
    const HANDLE_COLOR = "#F59E0B";
    const MOVER_RANGE_INDICATOR_COLOR = "rgba(100, 100, 255, 0.5)";
    const MOVER_RANGE_INDICATOR_WIDTH = 2;

    // --- Default Files & Fallback Size ---
    const DEFAULT_LEVEL_FILES = [
        './data/levels/Level_1.json',
        './data/levels/Level_2.json'
    ];
    // *** MODIFIED: Fallback size is now the primary reference for SIZE scaling ***
    const FALLBACK_CANVAS_WIDTH = 800;
    const FALLBACK_CANVAS_HEIGHT = 600;


    // --- Game State Variables ---
    let gameState = {
        player: { x: 0, y: 0, width: 0, height: 0, headRadius: 0 },
        ball: { x: 0, y: 0, radius: 0, vx: 0, vy: 0, fired: false, onPlayer: true },
        hole: { x: 0, y: 0, radius: 0 },
        bricks: [],
        currentLevelIndex: 0,
        mode: 'editor',
        // *** MODIFIED: Store SIZE scaling factors (relative to fallback) ***
        lastSizeScaleX: 1,
        lastSizeScaleY: 1,
        lastSizeScaleMin: 1,
        // Scaled constants
        scaledPlayerBottomOffset: 0,
        scaledMinBrickDimension: 0,
        scaledHandleSize: 0,
        scaledRotateHandleOffset: 0,
        scaledAimLineLength: 0,
        scaledBallOutlineWidth: 0,
    };

    // --- Editor State Variables ---
    let editorState = {
        selectedItems: [],
        draggingHandle: null,
        dragStart: { x: 0, y: 0 },
        originalItemStates: [],
        mouse: { x: 0, y: 0, down: false, dragStartX: 0, dragStartY: 0 },
        aim: { dx: 0, dy: 0, active: false },
        isMarqueeSelecting: false,
        marqueeStart: { x: 0, y: 0 },
        marqueeEnd: { x: 0, y: 0 },
        isDraggingSelection: false,
        clipboard: [],
        history: [],
        historyIndex: -1,
        isNudging: false,
        contextMenuTarget: null,
        isUpdatingPropertiesFromInput: false,
    };

    // --- Level Data ---
    let levelManager = {
        levels: [],
        storageKey: 'bounceBackLevels_v3', // Keep version 3

        loadLevelsFromStorage: async function() {
            const storedLevels = localStorage.getItem(this.storageKey);
            let loadedFromStorage = false;
            if (storedLevels) {
                try {
                    const parsedLevels = JSON.parse(storedLevels);
                    if (Array.isArray(parsedLevels) && parsedLevels.length > 0 && typeof parsedLevels[0] === 'object' && parsedLevels[0].bricks && parsedLevels[0].player && parsedLevels[0].hole && parsedLevels[0].savedCanvasWidth) {
                        this.levels = parsedLevels;
                        this.levels.forEach((lvl, index) => this._validateAndDefaultLevel(lvl, index));
                        loadedFromStorage = true;
                        console.log("Loaded levels from localStorage.");
                    } else { console.warn("Invalid level structure in localStorage v3."); }
                } catch (e) { console.error("Failed to parse levels from localStorage:", e); uiManager.showMessage("Error loading saved levels. Loading defaults.", 3000); this.levels = []; }
            }
            if (!loadedFromStorage) {
                console.log("No valid levels in localStorage, attempting to fetch defaults...");
                try {
                    const responses = await Promise.all( DEFAULT_LEVEL_FILES.map(url => fetch(url)) );
                    const allOk = responses.every(res => res.ok);
                    if (!allOk) { const failed = responses.filter(res => !res.ok); throw new Error(`Failed to fetch default levels: ${failed.map(f => f.url + ' ('+f.statusText+')').join(', ')}`); }
                    const fetchedLevelData = await Promise.all( responses.map(res => res.json()) );
                    if (fetchedLevelData.length > 0) {
                        this.levels = fetchedLevelData;
                        this.levels.forEach((lvl, index) => this._validateAndDefaultLevel(lvl, index));
                        console.log(`Successfully fetched and validated ${this.levels.length} default levels.`);
                        this.saveLevelsToStorage();
                    } else { throw new Error("Fetched default level data was empty."); }
                } catch (fetchError) {
                    console.error("Failed to fetch or process default levels:", fetchError);
                    uiManager.showMessage("Could not load default levels. Using fallback.", 3000);
                    this.levels = [this._createDefaultLevelData(0)];
                }
            }
            if (this.levels.length === 0) { console.warn("Level loading resulted in empty array, creating fallback."); this.levels = [this._createDefaultLevelData(0)]; }
            gameState.currentLevelIndex = 0;
            this.populateLevelList();
        },
        saveLevelsToStorage: function() {
             try {
                 const levelsToSave = utils.deepClone(this.levels);
                 levelsToSave.forEach(level => {
                     if (!level.bricks || !level.player || !level.hole || !level.savedCanvasWidth) {
                         console.warn("Attempting to save incomplete level structure:", level);
                     }
                 });
                 localStorage.setItem(this.storageKey, JSON.stringify(levelsToSave));
                 console.log("Saved levels to localStorage.");
             } catch (e) {
                 console.error("Failed to save levels to localStorage:", e);
                 uiManager.showMessage("Error saving levels. Storage might be full.", 3000);
             }
        },

        _validateAndDefaultLevel: function(lvl, index) {
            // console.log(`[Validate Debug] Validating level index ${index}, initial data:`, utils.deepClone(lvl));
            const defaultLvl = this._createDefaultLevelData(index);
            if (typeof lvl !== 'object' || lvl === null) { console.warn("[Validate Debug] Invalid level object provided."); return; }

            lvl.name = lvl.name || `Level ${index + 1}`;
            lvl.savedCanvasWidth = lvl.savedCanvasWidth || defaultLvl.savedCanvasWidth;
            lvl.savedCanvasHeight = lvl.savedCanvasHeight || defaultLvl.savedCanvasHeight;

            lvl.player = lvl.player || defaultLvl.player;
            if (lvl.player.x === undefined || lvl.player.y === undefined) { console.warn(`[Validate Debug] Invalid player data for level ${index}, using default.`); lvl.player = defaultLvl.player; }

            lvl.hole = lvl.hole || defaultLvl.hole;
            if (lvl.hole.x === undefined || lvl.hole.y === undefined) { console.warn(`[Validate Debug] Invalid hole data for level ${index}, using default.`); lvl.hole = defaultLvl.hole; }

            lvl.bricks = Array.isArray(lvl.bricks) ? lvl.bricks : defaultLvl.bricks;
            lvl.bricks.forEach((brick, brickIndex) => {
                if (typeof brick !== 'object' || brick === null) { console.warn(`[Validate Debug] Invalid brick object at index ${brickIndex} for level ${index}.`); return; }
                brick.isKillBrick = brick.isKillBrick || false;
                brick.movementType = brick.movementType || null;
                brick.moveRange = brick.moveRange ?? BASE_DEFAULT_MOVE_RANGE;
                brick.moveSpeed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED;
                brick.angle = brick.angle || 0;
                brick.x = brick.x ?? (FALLBACK_CANVAS_WIDTH / 2 - 50);
                brick.y = brick.y ?? (FALLBACK_CANVAS_HEIGHT / 2);
                brick.width = brick.width ?? 100;
                brick.height = brick.height ?? 20;

                if (brick.movementType && (brick.initialX === undefined || brick.initialY === undefined)) { console.warn(`[Validate Debug] Mover brick at index ${brickIndex} (level ${index}) missing initialX/Y, setting from current x/y.`); brick.initialX = brick.x; brick.initialY = brick.y; }
            });
             // console.log(`[Validate Debug] Validated level index ${index}, final data:`, utils.deepClone(lvl));
        },

        _createDefaultLevelData: function(levelIndex = 0) {
            console.log("Creating fallback default level data (unscaled).");
            const fallbackWidth = FALLBACK_CANVAS_WIDTH;
            const fallbackHeight = FALLBACK_CANVAS_HEIGHT;
            const centerX = fallbackWidth / 2;
            const fallbackBricks = [
                { x: centerX - 150, y: 300, width: 200, height: 15, angle: -Math.PI / 16, isKillBrick: false, movementType: null, moveRange: BASE_DEFAULT_MOVE_RANGE, moveSpeed: DEFAULT_MOVE_SPEED },
                { x: centerX - 50, y: 180, width: 100, height: 15, angle: 0, isKillBrick: false, movementType: 'horizontal', moveRange: 80, moveSpeed: 1.5, initialX: centerX - 50, initialY: 180 },
                { x: centerX + 150 - (15/2), y: 250, width: 15, height: 80, angle: 0, isKillBrick: true, movementType: 'vertical', moveRange: 40, moveSpeed: 0.8, initialX: centerX + 150 - (15/2), initialY: 250 }
            ];
            return {
                name: `Fallback Level ${levelIndex + 1}`,
                savedCanvasWidth: fallbackWidth,
                savedCanvasHeight: fallbackHeight,
                bricks: fallbackBricks,
                player: { x: centerX - (BASE_PLAYER_WIDTH / 2), y: fallbackHeight - BASE_PLAYER_DEFAULT_BOTTOM_OFFSET },
                hole: { x: centerX, y: BASE_HOLE_DEFAULT_Y }
            };
        },

        // *** MODIFIED: Separated Position and Size Scaling ***
        loadLevelData: function(index) {
            console.log(`[Load Debug] Loading level index: ${index}`);
            if (index < 0 || index >= this.levels.length) {
                console.error("[Load Debug] Attempted to load invalid level index:", index);
                index = 0;
                if (this.levels.length === 0) {
                    console.log("[Load Debug] No levels exist, creating default level 0.");
                    this.levels.push(this._createDefaultLevelData(0));
                }
            }
            const levelData = this.levels[index];
            if (typeof levelData !== 'object' || levelData === null || !Array.isArray(levelData.bricks) || !levelData.player || !levelData.hole) {
                console.error("[Load Debug] Invalid level data structure at index:", index, levelData);
                uiManager.showMessage(`Error: Corrupted level data for Level ${index + 1}.`, 3000);
                return;
            }
            console.log("[Load Debug] Level data to load (unscaled):", utils.deepClone(levelData));

            // --- Scaling Calculation ---
            const currentWidth = canvas.width;
            const currentHeight = canvas.height;

            // Position Scaling (relative to saved size)
            const positionReferenceWidth = levelData.savedCanvasWidth || FALLBACK_CANVAS_WIDTH; // Use saved size for pos ref
            const positionReferenceHeight = levelData.savedCanvasHeight || FALLBACK_CANVAS_HEIGHT;
            const positionScaleX = (positionReferenceWidth > 0) ? currentWidth / positionReferenceWidth : 1;
            const positionScaleY = (positionReferenceHeight > 0) ? currentHeight / positionReferenceHeight : 1;

            // Size Scaling (relative to fallback/design size)
            const sizeReferenceWidth = FALLBACK_CANVAS_WIDTH; // Always use fallback for size ref
            const sizeReferenceHeight = FALLBACK_CANVAS_HEIGHT;
            const sizeScaleX = (sizeReferenceWidth > 0) ? currentWidth / sizeReferenceWidth : 1;
            const sizeScaleY = (sizeReferenceHeight > 0) ? currentHeight / sizeReferenceHeight : 1;
            const sizeScaleMin = Math.min(sizeScaleX, sizeScaleY);

            // Store SIZE scales for saving/editing reference
            gameState.lastSizeScaleX = sizeScaleX;
            gameState.lastSizeScaleY = sizeScaleY;
            gameState.lastSizeScaleMin = sizeScaleMin;

            console.log(`[Load Debug] Position Scales - X: ${positionScaleX.toFixed(2)}, Y: ${positionScaleY.toFixed(2)} (Ref: ${positionReferenceWidth}x${positionReferenceHeight})`);
            console.log(`[Load Debug] Size Scales - X: ${sizeScaleX.toFixed(2)}, Y: ${sizeScaleY.toFixed(2)}, Min: ${sizeScaleMin.toFixed(2)} (Ref: ${sizeReferenceWidth}x${sizeReferenceHeight})`);
            // --- End Scaling Calculation ---

            // --- Apply Scaling and Update gameState ---

            // Scale runtime constants using SIZE scales
            gameState.scaledPlayerBottomOffset = BASE_PLAYER_DEFAULT_BOTTOM_OFFSET * sizeScaleY;
            gameState.scaledMinBrickDimension = BASE_MIN_BRICK_DIMENSION * sizeScaleMin;
            gameState.scaledHandleSize = BASE_HANDLE_SIZE * sizeScaleMin;
            gameState.scaledRotateHandleOffset = BASE_ROTATE_HANDLE_OFFSET * sizeScaleMin;
            gameState.scaledAimLineLength = BASE_AIM_LINE_LENGTH * sizeScaleMin;
            gameState.scaledBallOutlineWidth = BASE_BALL_OUTLINE_WIDTH * sizeScaleMin;

            // Load and scale bricks into gameState.bricks
            gameState.bricks = levelData.bricks.map(brickData => {
                if (typeof brickData !== 'object' || brickData === null) { return null; }
                // Load unscaled data
                const unscaledX = brickData.x || 0;
                const unscaledY = brickData.y || 0;
                const unscaledWidth = brickData.width || 100;
                const unscaledHeight = brickData.height || 20;
                const unscaledInitialX = brickData.initialX !== undefined ? brickData.initialX : unscaledX;
                const unscaledInitialY = brickData.initialY !== undefined ? brickData.initialY : unscaledY;
                const unscaledMoveRange = brickData.moveRange ?? BASE_DEFAULT_MOVE_RANGE;

                // Scale position using POSITION scales
                const scaledX = unscaledX * positionScaleX;
                const scaledY = unscaledY * positionScaleY;
                const scaledInitialX = unscaledInitialX * positionScaleX;
                const scaledInitialY = unscaledInitialY * positionScaleY;

                // Scale dimensions using SIZE scales
                const scaledWidth = Math.max(gameState.scaledMinBrickDimension, unscaledWidth * sizeScaleX);
                const scaledHeight = Math.max(gameState.scaledMinBrickDimension, unscaledHeight * sizeScaleY);

                // Scale range using SIZE scales
                let scaledMoveRange = unscaledMoveRange;
                if (brickData.movementType === 'horizontal') {
                    scaledMoveRange *= sizeScaleX;
                } else if (brickData.movementType === 'vertical') {
                    scaledMoveRange *= sizeScaleY;
                }

                // Return object with *scaled* values for gameState
                return {
                    angle: brickData.angle || 0, isKillBrick: brickData.isKillBrick || false, movementType: brickData.movementType || null, moveSpeed: brickData.moveSpeed ?? DEFAULT_MOVE_SPEED,
                    x: scaledX, y: scaledY, width: scaledWidth, height: scaledHeight, initialX: scaledInitialX, initialY: scaledInitialY, moveRange: scaledMoveRange,
                    baseWidth: unscaledWidth, baseHeight: unscaledHeight, // Keep unscaled base for reference
                };
            }).filter(brick => brick !== null);


            // Load and scale player into gameState.player
            const savedPlayer = levelData.player;
            // Scale position using POSITION scales
            gameState.player.x = (savedPlayer.x || positionReferenceWidth / 2) * positionScaleX;
            gameState.player.y = (savedPlayer.y || positionReferenceHeight - BASE_PLAYER_DEFAULT_BOTTOM_OFFSET) * positionScaleY;
            // Scale dimensions using SIZE scales
            gameState.player.width = BASE_PLAYER_WIDTH * sizeScaleX;
            gameState.player.height = BASE_PLAYER_HEIGHT * sizeScaleY;
            gameState.player.headRadius = BASE_PLAYER_HEAD_RADIUS * sizeScaleMin;

            // Load and scale hole into gameState.hole
            const savedHole = levelData.hole;
             // Scale position using POSITION scales
            gameState.hole.x = (savedHole.x || positionReferenceWidth / 2) * positionScaleX;
            gameState.hole.y = (savedHole.y || BASE_HOLE_DEFAULT_Y) * positionScaleY; // Scale default Y too? Maybe keep Y relative to top? Let's scale for now.
             // Scale radius using SIZE scales
            gameState.hole.radius = BASE_HOLE_RADIUS * sizeScaleMin;

            // Load and scale ball into gameState.ball
            gameState.ball.radius = BASE_BALL_RADIUS * sizeScaleMin; // Scale radius using SIZE scale
            console.log("[Load Debug] Scaled gameState:", utils.deepClone(gameState));
            // --- Update UI and Reset ---
            gameState.currentLevelIndex = index;
            uiManager.updateLevelDisplays();
            gameLogic.resetBall();
            editor.resetSelectionAndHistory();
            historyManager.saveState(true);
            uiManager.updateBrickPropertiesUI();
             console.log("[Load Debug] Level loading complete.");
        },

        // *** MODIFIED: Saves unscaled dimensions/range using SIZE scales ***
        saveCurrentLevel: function() {
            if (gameState.mode !== 'editor') return;
            const index = gameState.currentLevelIndex;
            if (index < 0 || index >= this.levels.length) {
                console.error("Cannot save, invalid level index selected:", index);
                uiManager.showMessage("Error: Invalid level selected for saving.", 2000);
                return;
            }

            const levelData = this.levels[index];

            const currentWidth = canvas.width;
            const currentHeight = canvas.height;
            levelData.savedCanvasWidth = currentWidth;
            levelData.savedCanvasHeight = currentHeight;

            // Use the SIZE scaling factors that were active for the current gameState
            const lastSizeScaleX = gameState.lastSizeScaleX || 1;
            const lastSizeScaleY = gameState.lastSizeScaleY || 1;

            // Store unscaled brick data
            levelData.bricks = gameState.bricks.map(brick => {
                // Get current scaled positions
                const scaledX = brick.initialX !== undefined ? brick.initialX : brick.x;
                const scaledY = brick.initialY !== undefined ? brick.initialY : brick.y;
                const scaledMoveRange = brick.moveRange;

                // Calculate unscaled positions relative to the canvas size *being saved*
                const unscaledX = scaledX; // Position is already absolute relative to current canvas
                const unscaledY = scaledY;

                // Get base unscaled dimensions (preferred) or reverse SIZE scaling
                const unscaledWidth = brick.baseWidth !== undefined ? brick.baseWidth : brick.width / lastSizeScaleX;
                const unscaledHeight = brick.baseHeight !== undefined ? brick.baseHeight : brick.height / lastSizeScaleY;

                // Reverse SIZE scaling for move range
                let unscaledMoveRange = scaledMoveRange;
                if (brick.movementType === 'horizontal' && lastSizeScaleX !== 0) {
                    unscaledMoveRange /= lastSizeScaleX;
                } else if (brick.movementType === 'vertical' && lastSizeScaleY !== 0) {
                    unscaledMoveRange /= lastSizeScaleY;
                }

                return {
                    angle: brick.angle || 0, isKillBrick: brick.isKillBrick || false, movementType: brick.movementType || null, moveSpeed: brick.moveSpeed ?? DEFAULT_MOVE_SPEED,
                    x: unscaledX, // Save absolute X relative to savedCanvasWidth
                    y: unscaledY, // Save absolute Y relative to savedCanvasHeight
                    width: unscaledWidth, // Save base unscaled width
                    height: unscaledHeight, // Save base unscaled height
                    moveRange: unscaledMoveRange, // Save base unscaled range
                    initialX: brick.initialX !== undefined ? brick.initialX : undefined, // Save absolute initial X
                    initialY: brick.initialY !== undefined ? brick.initialY : undefined, // Save absolute initial Y
                };
            });

            // Store absolute player and hole positions relative to saved canvas size
            levelData.player = { x: gameState.player.x, y: gameState.player.y };
            levelData.hole = { x: gameState.hole.x, y: gameState.hole.y };

            this.saveLevelsToStorage();
            uiManager.showMessage(`Level ${index + 1} ('${levelData.name}') saved!`, 1500);
            this.populateLevelList();
        },
        populateLevelList: function() { /* ... unchanged ... */ },
        selectLevelToEdit: function(index) { /* ... unchanged ... */ },
        renameLevel: function(index) { /* ... unchanged ... */ },
        addNew: function() { /* ... unchanged ... */ },
        deleteSelected: function() { /* ... unchanged ... */ },
        moveLevelUp: function(index) { /* ... unchanged ... */ },
        moveLevelDown: function(index) { /* ... unchanged ... */ },
        exportSelected: function() { /* ... unchanged ... */ },
        importLevels: function() { /* ... unchanged ... */ },
        handleFileImport: function(event) { /* ... unchanged ... */ },
    };
    levelManager.populateLevelList = function() { levelListElement.innerHTML = ''; if (!Array.isArray(this.levels)) { console.error("Cannot populate level list: levels data is not an array."); this.levels = []; return; } this.levels.forEach((levelData, index) => { if (typeof levelData !== 'object' || levelData === null) { console.warn(`Skipping invalid level data at index ${index} in populateLevelList.`); return; } const li = document.createElement('li'); li.onclick = (e) => { if (e.target.closest('.level-controls')) return; this.selectLevelToEdit(index); }; if (index === gameState.currentLevelIndex) { li.classList.add('selected'); } const nameSpan = document.createElement('span'); nameSpan.className = 'level-name'; nameSpan.textContent = levelData.name || `Level ${index + 1}`; nameSpan.title = "Double-click to rename"; nameSpan.ondblclick = (e) => { console.log(`[Rename Debug] Double-click detected on level index: ${index}`); e.stopPropagation(); this.renameLevel(index); }; li.appendChild(nameSpan); const controlsDiv = document.createElement('div'); controlsDiv.className = 'level-controls'; const upButton = uiManager.createLevelControlButton('&uarr;', "Move Up", () => this.moveLevelUp(index), index === 0); const downButton = uiManager.createLevelControlButton('&darr;', "Move Down", () => this.moveLevelDown(index), index === this.levels.length - 1); controlsDiv.appendChild(upButton); controlsDiv.appendChild(downButton); li.appendChild(controlsDiv); levelListElement.appendChild(li); }); uiManager.updateLevelDisplays(); };
    levelManager.selectLevelToEdit = function(index) { if (index >= 0 && index < this.levels.length) { this.loadLevelData(index); this.populateLevelList(); if (gameState.mode === 'play') { gameState.mode = 'play'; uiManager.updateUIForMode(); drawing.draw(); } else { gameState.mode = 'editor'; uiManager.updateUIForMode(); drawing.draw(); } } else { console.error("Invalid level index selected:", index); } };
    levelManager.renameLevel = function(index) { console.log(`[Rename Debug] renameLevel called for index: ${index}`); if (index < 0 || index >= this.levels.length) { console.log("[Rename Debug] Invalid index, exiting renameLevel."); return; } const currentName = this.levels[index].name || `Level ${index + 1}`; const newName = prompt(`Enter new name for "${currentName}":`, currentName); console.log(`[Rename Debug] Prompt returned: ${newName}`); if (newName === null) { console.log("[Rename Debug] User cancelled prompt."); return; } const trimmedName = newName.trim(); if (trimmedName === '') { console.log("[Rename Debug] Trimmed name is empty."); uiManager.showMessage("Level name cannot be empty.", 2000); return; } if (trimmedName !== currentName) { console.log(`[Rename Debug] Attempting to rename to: "${trimmedName}"`); this.levels[index].name = trimmedName; console.log("[Rename Debug] Name updated in memory. Saving..."); this.saveLevelsToStorage(); console.log("[Rename Debug] Saved. Repopulating list..."); this.populateLevelList(); console.log("[Rename Debug] List repopulated."); uiManager.showMessage(`Level ${index + 1} renamed to "${trimmedName}"`, 1500); } else { console.log("[Rename Debug] New name is the same as the old name."); } };
    levelManager.addNew = function() { historyManager.saveState(); const newLevelData = this._createDefaultLevelData(this.levels.length); newLevelData.savedCanvasWidth = canvas.width; newLevelData.savedCanvasHeight = canvas.height; this.levels.push(newLevelData); this.saveLevelsToStorage(); this.selectLevelToEdit(this.levels.length - 1); uiManager.showMessage(`Added new Level ${this.levels.length}`, 1500); };
    levelManager.deleteSelected = function() { const index = gameState.currentLevelIndex; if (this.levels.length <= 1) { uiManager.showMessage("Cannot delete the last level!", 2000); return; } if (confirm(`Are you sure you want to delete Level ${index + 1} ('${this.levels[index].name}')? This cannot be undone.`)) { historyManager.saveState(); this.levels.splice(index, 1); this.saveLevelsToStorage(); const newIndex = Math.max(0, index - 1); this.selectLevelToEdit(newIndex); uiManager.showMessage(`Deleted Level ${index + 1}`, 1500); } };
    levelManager.moveLevelUp = function(index) { if (index > 0) { historyManager.saveState(); [this.levels[index], this.levels[index - 1]] = [this.levels[index - 1], this.levels[index]]; this.saveLevelsToStorage(); this.selectLevelToEdit(index - 1); } };
    levelManager.moveLevelDown = function(index) { if (index < this.levels.length - 1) { historyManager.saveState(); [this.levels[index], this.levels[index + 1]] = [this.levels[index + 1], this.levels[index]]; this.saveLevelsToStorage(); this.selectLevelToEdit(index + 1); } };
    levelManager.exportSelected = function() { const index = gameState.currentLevelIndex; if (index < 0 || index >= this.levels.length) { uiManager.showMessage("No level selected to export.", 2000); return; } try { if (gameState.mode === 'editor') { this.saveCurrentLevel(); } const levelDataToExport = utils.deepClone(this.levels[index]); if (!levelDataToExport || !levelDataToExport.bricks || !levelDataToExport.player || !levelDataToExport.hole || !levelDataToExport.savedCanvasWidth || !levelDataToExport.savedCanvasHeight) { throw new Error("Level data is incomplete for export."); } const levelJson = JSON.stringify(levelDataToExport, null, 2); const levelName = utils.sanitizeFilename(levelDataToExport.name || `level_${index + 1}`); const filename = `${levelName}.json`; const blob = new Blob([levelJson], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); uiManager.showMessage(`Level '${levelDataToExport.name}' exported as ${filename}`, 2000); } catch (error) { console.error("Export failed:", error); uiManager.showMessage(`Failed to export level: ${error.message}`, 3000); } };
    levelManager.importLevels = function() { importFileInput.click(); };
    levelManager.handleFileImport = function(event) { const files = event.target.files; if (!files || files.length === 0) { return; } console.log(`[Import Debug] Starting import for ${files.length} file(s).`); historyManager.saveState(); let importedCount = 0; let failedCount = 0; const promises = []; Array.from(files).forEach((file, fileIndex) => { promises.push(new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { console.log(`[Import Debug] File ${fileIndex + 1} (${file.name}) read successfully.`); try { const levelData = JSON.parse(e.target.result); console.log(`[Import Debug] File ${fileIndex + 1} parsed JSON:`, utils.deepClone(levelData)); if (typeof levelData !== 'object' || !levelData.name || !Array.isArray(levelData.bricks) || typeof levelData.player !== 'object' || typeof levelData.hole !== 'object' || typeof levelData.savedCanvasWidth !== 'number' || typeof levelData.savedCanvasHeight !== 'number') { throw new Error(`Invalid base level structure or missing required fields (name, bricks, player, hole, savedCanvasWidth/Height) in file ${file.name}.`); } this._validateAndDefaultLevel(levelData, this.levels.length); this.levels.push(levelData); importedCount++; console.log(`[Import Debug] File ${fileIndex + 1} (${file.name}) validated and added.`); resolve(); } catch (error) { console.error(`[Import Debug] Failed to parse or validate file ${file.name}:`, error); failedCount++; reject(error); } }; reader.onerror = (e) => { console.error(`[Import Debug] Failed to read file ${file.name}:`, e); failedCount++; reject(e); }; reader.readAsText(file); })); }); Promise.allSettled(promises).then(() => { console.log(`[Import Debug] Import process finished. Imported: ${importedCount}, Failed: ${failedCount}`); let message = ""; if (importedCount > 0) { message += `Imported ${importedCount} level(s). `; this.saveLevelsToStorage(); this.populateLevelList(); this.selectLevelToEdit(this.levels.length - 1); } if (failedCount > 0) { message += `${failedCount} import(s) failed. Check console for details.`; } if (message) { uiManager.showMessage(message, importedCount > 0 ? 2500 : 3000); } event.target.value = null; }); };


    // --- Vector Math Helper ---
    const Vec = { create: (x = 0, y = 0) => ({ x, y }), add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }), sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }), scale: (v, s) => ({ x: v.x * s, y: v.y * s }), dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y, lenSq: (v) => v.x * v.x + v.y * v.y, len: (v) => Math.sqrt(Vec.lenSq(v)), normalize: (v) => { const l = Vec.len(v); return l === 0 ? Vec.create() : Vec.scale(v, 1 / l); }, perp: (v) => ({ x: -v.y, y: v.x }), reflect: (v, normal) => { const d = Vec.dot(v, normal); return Vec.sub(v, Vec.scale(normal, 2 * d)); }, rotate: (v, angle) => { const cosA = Math.cos(angle); const sinA = Math.sin(angle); return { x: v.x * cosA - v.y * sinA, y: v.x * sinA + v.y * cosA }; } };

    // --- Utility Functions ---
    const utils = {
        resizeCanvas: () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!canvas.classList.contains('hidden')) {
                 levelManager.loadLevelData(gameState.currentLevelIndex);
            } else {
                 // drawing.draw(); // Avoid drawing if hidden
            }
        },
        getRectVertices: (brick) => {
            const cx = brick.x + brick.width / 2; const cy = brick.y + brick.height / 2; const hw = brick.width / 2; const hh = brick.height / 2; const angle = brick.angle || 0; const cosA = Math.cos(angle); const sinA = Math.sin(angle); const corners = [ { x: -hw, y: -hh }, { x: hw, y: -hh }, { x: hw, y: hh }, { x: -hw, y: hh } ]; return corners.map(corner => ({ x: cx + (corner.x * cosA - corner.y * sinA), y: cy + (corner.x * sinA + corner.y * cosA) }));
        },
        getRectAxes: (vertices) => {
            const axes = []; for (let i = 0; i < vertices.length; i++) { const p1 = vertices[i]; const p2 = vertices[(i + 1) % vertices.length]; const edge = Vec.sub(p2, p1); const normal = Vec.normalize(Vec.perp(edge)); if (!axes.some(ax => Math.abs(Vec.dot(ax, normal)) > 0.999)) { axes.push(normal); } } return axes;
        },
        projectShapeOntoAxis: (vertices, axis) => {
            let min = Vec.dot(vertices[0], axis); let max = min; for (let i = 1; i < vertices.length; i++) { const p = Vec.dot(vertices[i], axis); if (p < min) min = p; else if (p > max) max = p; } return { min, max };
        },
        projectCircleOntoAxis: (ball, axis) => {
            const centerProj = Vec.dot(Vec.create(ball.x, ball.y), axis); return { min: centerProj - ball.radius, max: centerProj + ball.radius };
        },
        checkCircleRectCollision: (ball, brick) => {
            const rectVertices = utils.getRectVertices(brick); const circleCenter = Vec.create(ball.x, ball.y); const rectCenter = Vec.create(brick.x + brick.width / 2, brick.y + brick.height / 2); const axes = utils.getRectAxes(rectVertices); let closestVertex = rectVertices[0]; let minDistSq = Vec.lenSq(Vec.sub(circleCenter, closestVertex)); for (let i = 1; i < rectVertices.length; i++) { const distSq = Vec.lenSq(Vec.sub(circleCenter, rectVertices[i])); if (distSq < minDistSq) { minDistSq = distSq; closestVertex = rectVertices[i]; } } const axisToClosestVertex = Vec.normalize(Vec.sub(circleCenter, closestVertex)); if (Vec.lenSq(axisToClosestVertex) > 0.0001 && !axes.some(ax => Math.abs(Vec.dot(ax, axisToClosestVertex)) > 0.999)) { axes.push(axisToClosestVertex); } let minOverlap = Infinity; let mtvAxis = null; for (const axis of axes) { const rectProj = utils.projectShapeOntoAxis(rectVertices, axis); const circleProj = utils.projectCircleOntoAxis(ball, axis); const overlap = Math.min(rectProj.max, circleProj.max) - Math.max(rectProj.min, circleProj.min); if (overlap <= 0) { return { collision: false }; } if (overlap < minOverlap) { minOverlap = overlap; mtvAxis = axis; } } const centerDirection = Vec.sub(circleCenter, rectCenter); if (Vec.dot(mtvAxis, centerDirection) < 0) { mtvAxis = Vec.scale(mtvAxis, -1); } return { collision: true, normal: mtvAxis, overlap: minOverlap };
        },
        isPointInRotatedRect: (px, py, brick) => {
            const hw = brick.width / 2; const hh = brick.height / 2; const cx = brick.x + hw; const cy = brick.y + hh; const angle = -(brick.angle || 0); const cosA = Math.cos(angle); const sinA = Math.sin(angle); const dx = px - cx; const dy = py - cy; const localX = dx * cosA - dy * sinA; const localY = dx * sinA + dy * cosA; return Math.abs(localX) <= hw && Math.abs(localY) <= hh;
        },
        getBrickHandles: (brick) => {
            const hw = brick.width / 2; const hh = brick.height / 2; const cx = brick.x + hw; const cy = brick.y + hh; const angle = brick.angle || 0; const cosA = Math.cos(angle); const sinA = Math.sin(angle); const scaledOffset = gameState.scaledRotateHandleOffset; const rotatePoint = (relX, relY) => ({ x: cx + (relX * cosA - relY * sinA), y: cy + (relX * sinA + relY * cosA) }); return { tl: rotatePoint(-hw, -hh), tr: rotatePoint(hw, -hh), bl: rotatePoint(-hw, hh), br: rotatePoint(hw, hh), rotate: rotatePoint(0, -hh - scaledOffset), center: { x: cx, y: cy } };
        },
        deepClone: (obj) => { try { return JSON.parse(JSON.stringify(obj)); } catch (e) { console.error("Deep clone failed:", e, obj); return null; } },
        selectionsAreEqual: (selA, selB) => { if (selA.length !== selB.length) return false; const sortFn = (a, b) => (a.type + a.index).localeCompare(b.type + b.index); const sortedA = [...selA].sort(sortFn); const sortedB = [...selB].sort(sortFn); return sortedA.every((item, i) => item.type === sortedB[i].type && item.index === sortedB[i].index); },
        getRectBoundingBox: (brick) => {
            const vertices = utils.getRectVertices(brick); let minX = vertices[0].x, maxX = vertices[0].x, minY = vertices[0].y, maxY = vertices[0].y; for (let i = 1; i < vertices.length; i++) { minX = Math.min(minX, vertices[i].x); maxX = Math.max(maxX, vertices[i].x); minY = Math.min(minY, vertices[i].y); maxY = Math.max(maxY, vertices[i].y); } return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        },
        doRectsOverlap: (rect1, rect2) => { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; },
        sanitizeFilename: (name) => { if (!name) return 'level'; return name.replace(/[^a-z0-9_\-\s.]/gi, '_').replace(/[\s_]+/g, '_'); },
        statesAreEqual: (stateA, stateB) => { try { return JSON.stringify(stateA) === JSON.stringify(stateB); } catch (e) { console.error("State comparison failed:", e); return false; } }
    };

    // --- History / Undo-Redo Manager ---
    const historyManager = {
        getCurrentStateSnapshot: () => { return { bricks: utils.deepClone(gameState.bricks), player: utils.deepClone(gameState.player), hole: utils.deepClone(gameState.hole), scaledPlayerBottomOffset: gameState.scaledPlayerBottomOffset, scaledMinBrickDimension: gameState.scaledMinBrickDimension, scaledHandleSize: gameState.scaledHandleSize, scaledRotateHandleOffset: gameState.scaledRotateHandleOffset, scaledAimLineLength: gameState.scaledAimLineLength, scaledBallOutlineWidth: gameState.scaledBallOutlineWidth, lastSizeScaleX: gameState.lastSizeScaleX, lastSizeScaleY: gameState.lastSizeScaleY, lastSizeScaleMin: gameState.lastSizeScaleMin, }; }, // *** MODIFIED: Renamed lastScale -> lastSizeScale ***
        saveState: (forceSave = false) => { if (gameState.mode !== 'editor') return; if (!forceSave && editorState.isNudging) return; editorState.isNudging = false; const currentState = historyManager.getCurrentStateSnapshot(); if (editorState.historyIndex >= 0 && utils.statesAreEqual(currentState, editorState.history[editorState.historyIndex])) { return; } editorState.history = editorState.history.slice(0, editorState.historyIndex + 1); editorState.history.push(currentState); editorState.historyIndex++; if (editorState.history.length > MAX_HISTORY) { editorState.history.shift(); editorState.historyIndex--; } },
        loadStateFromHistory: (stateData) => { if (!stateData) return; gameState.bricks = utils.deepClone(stateData.bricks); gameState.player = utils.deepClone(stateData.player); gameState.hole = utils.deepClone(stateData.hole); gameState.scaledPlayerBottomOffset = stateData.scaledPlayerBottomOffset; gameState.scaledMinBrickDimension = stateData.scaledMinBrickDimension; gameState.scaledHandleSize = stateData.scaledHandleSize; gameState.scaledRotateHandleOffset = stateData.scaledRotateHandleOffset; gameState.scaledAimLineLength = stateData.scaledAimLineLength; gameState.scaledBallOutlineWidth = stateData.scaledBallOutlineWidth; gameState.lastSizeScaleX = stateData.lastSizeScaleX; gameState.lastSizeScaleY = stateData.lastSizeScaleY; gameState.lastSizeScaleMin = stateData.lastSizeScaleMin; gameLogic.resetBall(); editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); }, // *** MODIFIED: Renamed lastScale -> lastSizeScale ***
        undo: () => { if (gameState.mode !== 'editor' || editorState.historyIndex <= 0) return; editorState.historyIndex--; const stateToLoad = editorState.history[editorState.historyIndex]; historyManager.loadStateFromHistory(stateToLoad); drawing.draw(); },
        redo: () => { if (gameState.mode !== 'editor' || editorState.historyIndex >= editorState.history.length - 1) return; editorState.historyIndex++; const stateToLoad = editorState.history[editorState.historyIndex]; historyManager.loadStateFromHistory(stateToLoad); drawing.draw(); }
    };

    // --- UI Manager ---
    const uiManager = {
        messageTimeoutId: null,
        hideMenu: () => { menuDiv.classList.add('hidden'); menuDiv.classList.remove('initially-hidden'); showMenuButton.classList.remove('hidden'); },
        showMenu: () => { menuDiv.classList.remove('hidden', 'initially-hidden'); showMenuButton.classList.add('hidden'); },
        showMessage: (text, duration = MESSAGE_DISPLAY_TIME) => { messageText.textContent = text; messageBox.style.display = 'block'; if (uiManager.messageTimeoutId) { clearTimeout(uiManager.messageTimeoutId); } if (duration > 0) { uiManager.messageTimeoutId = setTimeout(uiManager.hideMessage, duration); } },
        hideMessage: () => { messageBox.style.display = 'none'; if (uiManager.messageTimeoutId) { clearTimeout(uiManager.messageTimeoutId); uiManager.messageTimeoutId = null; } },
        updateUIForMode: () => { const isEditor = gameState.mode === 'editor'; editorControlsDiv.classList.toggle('hidden', !isEditor); saveButton.classList.toggle('hidden', !isEditor); editorButton.classList.toggle('bg-red-500', isEditor); editorButton.classList.toggle('hover:bg-red-600', isEditor); editorButton.classList.toggle('bg-green-500', !isEditor); editorButton.classList.toggle('hover:bg-green-600', !isEditor); playButton.classList.toggle('bg-red-500', !isEditor); playButton.classList.toggle('hover:bg-red-600', !isEditor); playButton.classList.toggle('bg-blue-500', isEditor); playButton.classList.toggle('hover:bg-blue-600', isEditor); uiManager.updateCursorStyle(editorState.mouse.x, editorState.mouse.y); uiManager.updateBrickPropertiesUI(); if (!isEditor) { uiManager.hideContextMenu(); editor.resetSelectionAndDragging(); } },
        updateLevelDisplays: () => { const displayLevel = gameState.currentLevelIndex + 1; levelDisplay.textContent = displayLevel; editingLevelDisplay.textContent = displayLevel; },
        showContextMenu: (x, y) => { contextMenuDiv.innerHTML = ''; const target = editorState.contextMenuTarget; if (target) { if (target.type === 'empty') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Brick', () => editor.addBrick('static'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Kill Brick', () => editor.addBrick('kill'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Vertical Mover', () => editor.addBrick('vertical'))); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Add Horizontal Mover', () => editor.addBrick('horizontal'))); } else if (target.type === 'brick' && target.index !== undefined) { const index = target.index; const brick = gameState.bricks[index]; if (!brick) return; const toggleKillText = brick.isKillBrick ? 'Make Normal Brick' : 'Make Kill Brick'; contextMenuDiv.appendChild(uiManager.createContextMenuButton(toggleKillText, () => editor.toggleKillBrick(index))); contextMenuDiv.appendChild(document.createElement('hr')); if (brick.movementType !== 'vertical') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Vertical Mover', () => editor.setMovementType(index, 'vertical'))); } if (brick.movementType !== 'horizontal') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Horizontal Mover', () => editor.setMovementType(index, 'horizontal'))); } if (brick.movementType !== null) { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Make Static', () => editor.setMovementType(index, null))); } contextMenuDiv.appendChild(document.createElement('hr')); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Copy', editor.handleCopy)); contextMenuDiv.appendChild(uiManager.createContextMenuButton('Delete Brick', () => editor.deleteSingleBrick(index))); } else if (target.type === 'player' || target.type === 'hole') { contextMenuDiv.appendChild(uiManager.createContextMenuButton('Cannot Delete', () => { uiManager.showMessage("Player and Hole cannot be deleted.", 1500); })); } } contextMenuDiv.style.left = `${x}px`; contextMenuDiv.style.top = `${y}px`; contextMenuDiv.style.display = 'block'; },
        hideContextMenu: () => { contextMenuDiv.style.display = 'none'; editorState.contextMenuTarget = null; },
        createContextMenuButton: (text, onClickAction) => { const button = document.createElement('button'); button.textContent = text; button.onclick = () => { onClickAction(); uiManager.hideContextMenu(); }; return button; },
        createLevelControlButton: (html, title, onClickAction, disabled = false) => { const button = document.createElement('button'); button.innerHTML = html; button.title = title; button.disabled = disabled; button.onclick = (e) => { e.stopPropagation(); onClickAction(); }; return button; },
        updateCursorStyle: (mx, my) => { if (!startMenu.classList.contains('hidden') || gameState.mode !== 'editor' || uiManager.isPointerOverUI(mx, my)) { canvas.style.cursor = 'default'; return; } let cursorSet = false; const scaledHandleHitSize = gameState.scaledHandleSize * 1.5; if (editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brick = gameState.bricks[editorState.selectedItems[0].index]; if (brick) { const handles = utils.getBrickHandles(brick); if (Math.hypot(mx - handles.rotate.x, my - handles.rotate.y) <= scaledHandleHitSize * ROTATE_HANDLE_SIZE_FACTOR) { canvas.style.cursor = 'grab'; cursorSet = true; } else { for (const type of ['tl', 'tr', 'bl', 'br']) { if (Math.hypot(mx - handles[type].x, my - handles[type].y) <= scaledHandleHitSize) { canvas.style.cursor = (type === 'tl' || type === 'br') ? 'nwse-resize' : 'nesw-resize'; cursorSet = true; break; } } } } } if (!cursorSet && editorState.selectedItems.length > 0) { if (editor.isPointOverSelection(mx, my)) { canvas.style.cursor = 'move'; cursorSet = true; } } if (!cursorSet) { const itemAtPoint = editor.getItemAtPoint(mx, my); if (itemAtPoint !== null) { canvas.style.cursor = 'pointer'; cursorSet = true; } } if (!cursorSet) { canvas.style.cursor = 'default'; } },
        isPointerOverUI: (px, py) => { if (!startMenu.classList.contains('hidden')) { const startRect = startMenu.getBoundingClientRect(); if (px >= startRect.left && px <= startRect.right && py >= startRect.top && py <= startRect.bottom) { return true; } } if (!menuDiv.classList.contains('hidden') && !menuDiv.classList.contains('initially-hidden')) { const menuRect = menuDiv.getBoundingClientRect(); if (px >= menuRect.left && px <= menuRect.right && py >= menuRect.top && py <= menuRect.bottom) { return true; } } if (!showMenuButton.classList.contains('hidden')) { const buttonRect = showMenuButton.getBoundingClientRect(); if (px >= buttonRect.left && px <= buttonRect.right && py >= buttonRect.top && py <= buttonRect.bottom) { return true; } } if (contextMenuDiv.style.display === 'block') { const contextRect = contextMenuDiv.getBoundingClientRect(); if (px >= contextRect.left && px <= contextRect.right && py >= contextRect.top && py <= contextRect.bottom) { return true; } } if (messageBox.style.display === 'block') { const messageRect = messageBox.getBoundingClientRect(); if (px >= messageRect.left && px <= messageRect.right && py >= messageRect.top && py <= messageRect.bottom) { return true; } } return false; },
        updateMarqueeBox: () => { if (editorState.isMarqueeSelecting) { const x = Math.min(editorState.marqueeStart.x, editorState.marqueeEnd.x); const y = Math.min(editorState.marqueeStart.y, editorState.marqueeEnd.y); const width = Math.abs(editorState.marqueeStart.x - editorState.marqueeEnd.x); const height = Math.abs(editorState.marqueeStart.y - editorState.marqueeEnd.y); marqueeBox.style.left = `${x}px`; marqueeBox.style.top = `${y}px`; marqueeBox.style.width = `${width}px`; marqueeBox.style.height = `${height}px`; marqueeBox.style.display = 'block'; } else { marqueeBox.style.display = 'none'; } },
        updateBrickPropertiesUI: () => { if (editorState.isUpdatingPropertiesFromInput) return; if (gameState.mode === 'editor' && editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brickIndex = editorState.selectedItems[0].index; if (brickIndex !== undefined && brickIndex >= 0 && brickIndex < gameState.bricks.length) { const brick = gameState.bricks[brickIndex]; if (brick) { brickPropertiesDiv.classList.remove('hidden'); const isMover = brick.movementType === 'vertical' || brick.movementType === 'horizontal'; propMoveRangeInput.disabled = !isMover; propMoveSpeedInput.disabled = !isMover; propMoveRangeInput.value = isMover ? (brick.moveRange ?? 0).toFixed(1) : ''; propMoveSpeedInput.value = isMover ? (brick.moveSpeed ?? DEFAULT_MOVE_SPEED).toFixed(1) : ''; propMoveRangeInput.placeholder = isMover ? '' : 'N/A (Static)'; propMoveSpeedInput.placeholder = isMover ? '' : 'N/A (Static)'; return; } } } brickPropertiesDiv.classList.add('hidden'); }
    };

    // --- Game Logic ---
    const gameLogic = {
        update: (deltaTime) => { if (!startMenu.classList.contains('hidden')) return; const time = Date.now() * 0.001; gameState.bricks.forEach(brick => { if (brick.movementType && brick.initialX !== undefined && brick.initialY !== undefined) { const speed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED; const range = brick.moveRange; const offset = range * Math.sin(time * speed); if (brick.movementType === 'vertical') { brick.y = brick.initialY + offset; } else if (brick.movementType === 'horizontal') { brick.x = brick.initialX + offset; } } }); if (gameState.mode === 'editor') return; if (gameState.ball.fired) { gameState.ball.x += gameState.ball.vx; gameState.ball.y += gameState.ball.vy; if (gameState.ball.x - gameState.ball.radius < 0 || gameState.ball.x + gameState.ball.radius > canvas.width || gameState.ball.y - gameState.ball.radius < 0) { gameLogic.restartLevelAttempt("Hit wall!"); return; } if (gameState.ball.y > canvas.height + gameState.ball.radius * 2) { gameLogic.restartLevelAttempt("Fell off bottom!"); return; } for (const brick of gameState.bricks) { const collision = utils.checkCircleRectCollision(gameState.ball, brick); if (collision.collision) { if (brick.isKillBrick) { gameLogic.restartLevelAttempt("Hit a kill brick!"); return; } const pushVector = Vec.scale(collision.normal, collision.overlap * COLLISION_PUSH_FACTOR); gameState.ball.x += pushVector.x; gameState.ball.y += pushVector.y; const velocity = Vec.create(gameState.ball.vx, gameState.ball.vy); const reflectedVel = Vec.reflect(velocity, collision.normal); gameState.ball.vx = reflectedVel.x; gameState.ball.vy = reflectedVel.y; } } const playerRect = { x: gameState.player.x, y: gameState.player.y, width: gameState.player.width, height: gameState.player.height }; const ballRect = { x: gameState.ball.x - gameState.ball.radius, y: gameState.ball.y - gameState.ball.radius, width: gameState.ball.radius * 2, height: gameState.ball.radius * 2 }; if (utils.doRectsOverlap(ballRect, playerRect)) { gameLogic.restartLevelAttempt("Ball hit player!"); return; } const distToHoleSq = Vec.lenSq(Vec.sub(Vec.create(gameState.ball.x, gameState.ball.y), Vec.create(gameState.hole.x, gameState.hole.y))); const radiiSumSq = (gameState.ball.radius + gameState.hole.radius) * (gameState.ball.radius + gameState.hole.radius); if (distToHoleSq < radiiSumSq) { uiManager.showMessage(`Level ${gameState.currentLevelIndex + 1} Complete!`); const nextLevelIndex = gameState.currentLevelIndex + 1; if (nextLevelIndex < levelManager.levels.length) { levelManager.selectLevelToEdit(nextLevelIndex); } else { uiManager.showMessage("Congratulations! You beat all levels!", 0); gameLogic.switchToEditorMode(); } return; } } else if (gameState.ball.onPlayer) { gameLogic.resetBallPosition(); } },
        resetBall: () => { gameState.ball.fired = false; gameState.ball.onPlayer = true; gameState.ball.vx = 0; gameState.ball.vy = 0; editorState.aim.active = false; editorState.aim.dx = 0; editorState.aim.dy = 0; gameLogic.resetBallPosition(); },
        resetBallPosition: () => { gameState.ball.x = gameState.player.x + gameState.player.width / 2; gameState.ball.y = gameState.player.y - gameState.ball.radius - (2 * gameState.lastSizeScaleMin); }, // *** MODIFIED: Use lastSizeScaleMin ***
        fireBall: () => { if (!gameState.ball.onPlayer || gameState.mode === 'editor' || !editorState.aim.active) return; if (Math.abs(editorState.aim.dx) < 0.01 && Math.abs(editorState.aim.dy) < 0.01) return; gameState.ball.fired = true; gameState.ball.onPlayer = false; gameState.ball.vx = editorState.aim.dx; gameState.ball.vy = editorState.aim.dy; editorState.aim.active = false; editorState.aim.dx = 0; editorState.aim.dy = 0; },
        restartLevelAttempt: (reason = "Hazard hit!") => { uiManager.showMessage(`${reason} Restarting level.`, MESSAGE_DISPLAY_TIME); gameLogic.resetBall(); drawing.draw(); },
        startGame: () => { gameState.mode = 'play'; editorState.aim.active = false; uiManager.hideContextMenu(); uiManager.hideMessage(); editor.resetSelectionAndDragging(); levelManager.loadLevelData(gameState.currentLevelIndex); uiManager.updateUIForMode(); },
        switchToEditorMode: () => { gameState.mode = 'editor'; editorState.aim.active = false; uiManager.hideContextMenu(); levelManager.loadLevelData(gameState.currentLevelIndex); uiManager.updateUIForMode(); }
    };

    // --- Drawing Functions ---
    const drawing = {
        draw: () => { if (canvas.classList.contains('hidden')) return; ctx.fillStyle = "#f0f8ff"; ctx.fillRect(0, 0, canvas.width, canvas.height); drawing.drawHole(); gameState.bricks.forEach((brick, index) => { drawing.drawBrick(brick, index); }); drawing.drawPlayer(); drawing.drawBall(); if (gameState.mode === 'play' && editorState.aim.active && gameState.ball.onPlayer) { drawing.drawAimLine(); } if (gameState.mode === 'editor') { drawing.drawEditorOverlays(); } },
        drawHole: () => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'hole'); ctx.fillStyle = "#222"; ctx.beginPath(); ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius, 0, Math.PI * 2); ctx.fill(); if (isSelected) { ctx.strokeStyle = SELECTED_ITEM_OUTLINE_COLOR; ctx.lineWidth = 2; ctx.stroke(); } },
        drawBrick: (brick, index) => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'brick' && item.index === index); ctx.save(); const centerX = brick.x + brick.width / 2; const centerY = brick.y + brick.height / 2; ctx.translate(centerX, centerY); ctx.rotate(brick.angle || 0); ctx.translate(-centerX, -centerY); let fillColor = BRICK_COLOR; if (brick.isKillBrick) fillColor = KILL_BRICK_COLOR; else if (brick.movementType === 'vertical') fillColor = VERTICAL_MOVER_COLOR; else if (brick.movementType === 'horizontal') fillColor = HORIZONTAL_MOVER_COLOR; if (isSelected) fillColor = SELECTED_BRICK_COLOR; ctx.fillStyle = fillColor; ctx.strokeStyle = BRICK_STROKE_COLOR; ctx.lineWidth = 1; ctx.fillRect(brick.x, brick.y, brick.width, brick.height); ctx.strokeRect(brick.x, brick.y, brick.width, brick.height); ctx.restore(); },
        drawPlayer: () => { const isSelected = gameState.mode === 'editor' && editorState.selectedItems.some(item => item.type === 'player'); const player = gameState.player; ctx.fillStyle = "#4CAF50"; ctx.fillRect(player.x, player.y, player.width, player.height); const headX = player.x + player.width / 2; const headY = player.y - player.headRadius; ctx.fillStyle = "#8BC34A"; ctx.beginPath(); ctx.arc(headX, headY, player.headRadius, 0, Math.PI * 2); ctx.fill(); if (isSelected) { ctx.strokeStyle = SELECTED_ITEM_OUTLINE_COLOR; ctx.lineWidth = 2; ctx.strokeRect(player.x, player.y, player.width, player.height); ctx.beginPath(); ctx.arc(headX, headY, player.headRadius, 0, Math.PI * 2); ctx.stroke(); } },
        drawBall: () => { ctx.save(); ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = gameState.scaledBallOutlineWidth; ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore(); },
        drawAimLine: () => { ctx.save(); ctx.beginPath(); ctx.moveTo(gameState.ball.x, gameState.ball.y); const potentialVx = editorState.aim.dx; const potentialVy = editorState.aim.dy; const endX = gameState.ball.x + potentialVx * AIM_VISUAL_SCALE; const endY = gameState.ball.y + potentialVy * AIM_VISUAL_SCALE; ctx.lineTo(endX, endY); ctx.strokeStyle = "rgba(255, 0, 0, 0.7)"; ctx.lineWidth = 2; ctx.setLineDash([5, 3]); ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.arc(endX, endY, 3 * gameState.lastSizeScaleMin, 0, Math.PI * 2); ctx.fillStyle = "rgba(255, 0, 0, 0.7)"; ctx.fill(); ctx.restore(); }, // *** MODIFIED: Use lastSizeScaleMin ***
        drawEditorOverlays: () => { if (editorState.selectedItems.length === 1 && editorState.selectedItems[0].type === 'brick') { const brickIndex = editorState.selectedItems[0].index; if (brickIndex !== undefined && brickIndex >= 0 && brickIndex < gameState.bricks.length) { const brick = gameState.bricks[brickIndex]; if (brick) { if (brick.movementType === 'vertical' || brick.movementType === 'horizontal') { drawing.drawMovementRange(brick); } drawing.drawHandles(brick); } } } },
        drawMovementRange: (brick) => { const initialCenterX = (brick.initialX ?? brick.x); const initialCenterY = (brick.initialY ?? brick.y); const range = brick.moveRange; ctx.save(); ctx.strokeStyle = MOVER_RANGE_INDICATOR_COLOR; ctx.lineWidth = MOVER_RANGE_INDICATOR_WIDTH; ctx.setLineDash([4, 4]); ctx.beginPath(); if (brick.movementType === 'vertical') { const y1 = initialCenterY - range + brick.height / 2; const y2 = initialCenterY + range + brick.height / 2; const centerX = initialCenterX + brick.width / 2; ctx.moveTo(centerX, y1); ctx.lineTo(centerX, y2); ctx.moveTo(centerX - 5, y1); ctx.lineTo(centerX + 5, y1); ctx.moveTo(centerX - 5, y2); ctx.lineTo(centerX + 5, y2); } else { const x1 = initialCenterX - range + brick.width / 2; const x2 = initialCenterX + range + brick.width / 2; const centerY = initialCenterY + brick.height / 2; ctx.moveTo(x1, centerY); ctx.lineTo(x2, centerY); ctx.moveTo(x1, centerY - 5); ctx.lineTo(x1, centerY + 5); ctx.moveTo(x2, centerY - 5); ctx.lineTo(x2, centerY + 5); } ctx.stroke(); ctx.restore(); },
        drawHandles: (brick) => { const handles = utils.getBrickHandles(brick); const scaledHandleDrawSize = gameState.scaledHandleSize * 2; ctx.fillStyle = HANDLE_COLOR; for (const type of ['tl', 'tr', 'bl', 'br']) { ctx.fillRect(handles[type].x - gameState.scaledHandleSize, handles[type].y - gameState.scaledHandleSize, scaledHandleDrawSize, scaledHandleDrawSize); } ctx.beginPath(); ctx.arc(handles.rotate.x, handles.rotate.y, gameState.scaledHandleSize * ROTATE_HANDLE_SIZE_FACTOR, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(handles.center.x, handles.center.y); ctx.lineTo(handles.rotate.x, handles.rotate.y); ctx.strokeStyle = HANDLE_COLOR; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]); }
    };

    // --- Editor Logic ---
    const editor = {
        resetSelectionAndHistory: () => { editorState.selectedItems = []; editor.resetSelectionAndDragging(); editorState.history = []; editorState.historyIndex = -1; uiManager.updateBrickPropertiesUI(); },
        resetSelectionAndDragging: () => { editorState.draggingHandle = null; editorState.isDraggingSelection = false; editorState.isMarqueeSelecting = false; editorState.originalItemStates = []; uiManager.updateMarqueeBox(); uiManager.updateCursorStyle(editorState.mouse.x, editorState.mouse.y); },
        // *** MODIFIED: Uses SIZE scales for dimensions/range ***
        addBrick: (type = 'static') => {
            if (gameState.mode !== 'editor' || !editorState.contextMenuTarget || editorState.contextMenuTarget.type !== 'empty') return;
            historyManager.saveState();

            // Use current SIZE scales (relative to fallback)
            const sizeScaleX = gameState.lastSizeScaleX;
            const sizeScaleY = gameState.lastSizeScaleY;

            const scaledCenterX = editorState.contextMenuTarget.x || editorState.mouse.x;
            const scaledCenterY = editorState.contextMenuTarget.y || editorState.mouse.y;

            const baseWidth = 100;
            const baseHeight = 20;
            const scaledWidth = Math.max(gameState.scaledMinBrickDimension, baseWidth * sizeScaleX);
            const scaledHeight = Math.max(gameState.scaledMinBrickDimension, baseHeight * sizeScaleY);

            const scaledX = scaledCenterX - scaledWidth / 2;
            const scaledY = scaledCenterY - scaledHeight / 2;

            let scaledMoveRange = BASE_DEFAULT_MOVE_RANGE;
             if (type === 'horizontal') scaledMoveRange *= sizeScaleX; // Use SIZE scale
             else if (type === 'vertical') scaledMoveRange *= sizeScaleY; // Use SIZE scale

            const newBrick = { x: scaledX, y: scaledY, width: scaledWidth, height: scaledHeight, angle: 0, isKillBrick: type === 'kill', movementType: (type === 'vertical' || type === 'horizontal') ? type : null, moveRange: scaledMoveRange, moveSpeed: DEFAULT_MOVE_SPEED, initialX: scaledX, initialY: scaledY, baseWidth: baseWidth, baseHeight: baseHeight, };
            gameState.bricks.push(newBrick);
            editorState.selectedItems = [{ type: 'brick', index: gameState.bricks.length - 1 }];
            editor.resetSelectionAndDragging();
            uiManager.updateBrickPropertiesUI();
            drawing.draw();
        },
        toggleKillBrick: (index) => { if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return; historyManager.saveState(); const brick = gameState.bricks[index]; brick.isKillBrick = !brick.isKillBrick; editor.ensureItemSelected({ type: 'brick', index: index }); uiManager.updateBrickPropertiesUI(); drawing.draw(); },
        // *** MODIFIED: Uses SIZE scales for range ***
        setMovementType: (index, type) => {
            if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return;
            historyManager.saveState();
            const brick = gameState.bricks[index];

            if (type === null) {
                brick.movementType = null;
                if (brick.initialX !== undefined) brick.x = brick.initialX;
                if (brick.initialY !== undefined) brick.y = brick.initialY;
            } else {
                if (brick.movementType !== type || brick.initialX === undefined || brick.initialY === undefined) {
                    brick.initialX = brick.x;
                    brick.initialY = brick.y;
                }
                brick.movementType = type;
                brick.moveSpeed = brick.moveSpeed ?? DEFAULT_MOVE_SPEED;

                // Calculate scaled move range from base default using SIZE scales
                const sizeScaleX = gameState.lastSizeScaleX;
                const sizeScaleY = gameState.lastSizeScaleY;
                let scaledMoveRange = BASE_DEFAULT_MOVE_RANGE;
                if (brick.movementType === 'horizontal') {
                    scaledMoveRange *= sizeScaleX;
                } else if (brick.movementType === 'vertical') {
                    scaledMoveRange *= sizeScaleY;
                }
                 // Reset range when changing type
                 brick.moveRange = scaledMoveRange;
            }
            editor.ensureItemSelected({ type: 'brick', index: index });
            uiManager.updateBrickPropertiesUI();
            drawing.draw();
        },
        deleteSingleBrick: (index) => { if (gameState.mode !== 'editor' || index < 0 || index >= gameState.bricks.length) return; historyManager.saveState(); gameState.bricks.splice(index, 1); editorState.selectedItems = editorState.selectedItems .filter(item => !(item.type === 'brick' && item.index === index)) .map(item => { if (item.type === 'brick' && item.index > index) { item.index--; } return item; }); editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); },
        deleteSelectedItems: () => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0) return; historyManager.saveState(); const itemsToDelete = editorState.selectedItems.filter(item => item.type === 'brick'); const triedToDeletePlayer = editorState.selectedItems.some(item => item.type === 'player'); const triedToDeleteHole = editorState.selectedItems.some(item => item.type === 'hole'); if (itemsToDelete.length === 0 && (triedToDeletePlayer || triedToDeleteHole)) { uiManager.showMessage("Player and Hole cannot be deleted.", 1500); return; } if (itemsToDelete.length === 0) return; const brickIndicesToDelete = itemsToDelete.map(item => item.index).sort((a, b) => b - a); brickIndicesToDelete.forEach(index => { if (index >= 0 && index < gameState.bricks.length) { gameState.bricks.splice(index, 1); } else { console.warn("Attempted to delete invalid brick index during multi-delete:", index); } }); editorState.selectedItems = []; editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); if (triedToDeletePlayer || triedToDeleteHole) { uiManager.showMessage("Deleted selected brick(s). Player and Hole cannot be deleted.", 2000); } },
        handleCopy: () => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0) return; const sizeScaleX = gameState.lastSizeScaleX || 1; const sizeScaleY = gameState.lastSizeScaleY || 1; editorState.clipboard = []; editorState.selectedItems.forEach(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (brick) { let unscaledMoveRange = brick.moveRange; if (brick.movementType === 'horizontal' && sizeScaleX !== 0) unscaledMoveRange /= sizeScaleX; else if (brick.movementType === 'vertical' && sizeScaleY !== 0) unscaledMoveRange /= sizeScaleY; editorState.clipboard.push({ x: brick.x, y: brick.y, width: brick.baseWidth !== undefined ? brick.baseWidth : brick.width / sizeScaleX, height: brick.baseHeight !== undefined ? brick.baseHeight : brick.height / sizeScaleY, angle: brick.angle, isKillBrick: brick.isKillBrick, movementType: brick.movementType, moveRange: unscaledMoveRange, moveSpeed: brick.moveSpeed, initialX: brick.initialX, initialY: brick.initialY, }); } } }); if (editorState.clipboard.length > 0) { uiManager.showMessage(`Copied ${editorState.clipboard.length} brick(s).`, 1000); } else { uiManager.showMessage(`Cannot copy Player or Hole.`, 1000); } }, // *** MODIFIED: Copy unscaled data, using SIZE scales for reversal ***
        handlePaste: () => { if (gameState.mode !== 'editor' || editorState.clipboard.length === 0) return; historyManager.saveState(); const sizeScaleX = gameState.lastSizeScaleX; const sizeScaleY = gameState.lastSizeScaleY; const sizeScaleMin = gameState.lastSizeScaleMin; const newSelection = []; editorState.clipboard.forEach(unscaledData => { if (unscaledData) { const scaledWidth = Math.max(gameState.scaledMinBrickDimension, unscaledData.width * sizeScaleX); const scaledHeight = Math.max(gameState.scaledMinBrickDimension, unscaledData.height * sizeScaleY); const scaledX = unscaledData.x + PASTE_OFFSET; const scaledY = unscaledData.y + PASTE_OFFSET; const scaledInitialX = unscaledData.initialX !== undefined ? unscaledData.initialX + PASTE_OFFSET : scaledX; const scaledInitialY = unscaledData.initialY !== undefined ? unscaledData.initialY + PASTE_OFFSET : scaledY; let scaledMoveRange = unscaledData.moveRange; if (unscaledData.movementType === 'horizontal') scaledMoveRange *= sizeScaleX; else if (unscaledData.movementType === 'vertical') scaledMoveRange *= sizeScaleY; const newItem = { ...unscaledData, x: scaledX, y: scaledY, width: scaledWidth, height: scaledHeight, initialX: scaledInitialX, initialY: scaledInitialY, moveRange: scaledMoveRange, baseWidth: unscaledData.width, baseHeight: unscaledData.height, }; gameState.bricks.push(newItem); newSelection.push({ type: 'brick', index: gameState.bricks.length - 1 }); } }); editorState.selectedItems = newSelection; editor.resetSelectionAndDragging(); uiManager.updateBrickPropertiesUI(); drawing.draw(); }, // *** MODIFIED: Apply SIZE scales to pasted data ***
        handleNudge: (dx, dy) => { if (gameState.mode !== 'editor' || editorState.selectedItems.length === 0 || (dx === 0 && dy === 0)) return; if (!editorState.isNudging) { historyManager.saveState(); editorState.isNudging = true; } editorState.selectedItems.forEach(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (brick) { brick.x += dx; brick.y += dy; if (brick.initialX !== undefined) brick.initialX += dx; if (brick.initialY !== undefined) brick.initialY += dy; } } else if (item.type === 'player') { gameState.player.x += dx; gameState.player.y += dy; if (gameState.ball.onPlayer) gameLogic.resetBallPosition(); } else if (item.type === 'hole') { gameState.hole.x += dx; gameState.hole.y += dy; } }); drawing.draw(); },
        selectItem: (itemToSelect, ctrlPressed) => { if (!itemToSelect) return; const alreadySelected = editorState.selectedItems.some(sel => sel.type === itemToSelect.type && sel.index === itemToSelect.index ); if (ctrlPressed) { if (alreadySelected) { editorState.selectedItems = editorState.selectedItems.filter(sel => !(sel.type === itemToSelect.type && sel.index === itemToSelect.index) ); } else { editorState.selectedItems.push(itemToSelect); } } else { if (!alreadySelected || editorState.selectedItems.length > 1) { editorState.selectedItems = [itemToSelect]; } } uiManager.updateBrickPropertiesUI(); },
        ensureItemSelected: (itemToSelect) => { if (!editorState.selectedItems.some(sel => sel.type === itemToSelect.type && sel.index === itemToSelect.index)) { editorState.selectedItems.push(itemToSelect); uiManager.updateBrickPropertiesUI(); } },
        getItemAtPoint: (px, py) => { for (let i = gameState.bricks.length - 1; i >= 0; i--) { if (utils.isPointInRotatedRect(px, py, gameState.bricks[i])) { return { type: 'brick', index: i }; } } const player = gameState.player; const headCenter = { x: player.x + player.width / 2, y: player.y - player.headRadius }; const distSqToHead = Vec.lenSq(Vec.sub({ x: px, y: py }, headCenter)); const isOverHead = distSqToHead <= (player.headRadius * player.headRadius); const isOverBody = px >= player.x && px <= player.x + player.width && py >= player.y && py <= player.y + player.height; if (isOverHead || isOverBody) { return { type: 'player', index: null }; } const distSqToHole = Vec.lenSq(Vec.sub({ x: px, y: py }, gameState.hole)); if (distSqToHole <= (gameState.hole.radius * gameState.hole.radius)) { return { type: 'hole', index: null }; } return null; },
        isPointOverSelection: (px, py) => { return editorState.selectedItems.some(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; return brick && utils.isPointInRotatedRect(px, py, brick); } else if (item.type === 'player') { const player = gameState.player; const headCenter = { x: player.x + player.width / 2, y: player.y - player.headRadius }; const distSqToHead = Vec.lenSq(Vec.sub({ x: px, y: py }, headCenter)); const isOverHead = distSqToHead <= (player.headRadius * player.headRadius); const isOverBody = px >= player.x && px <= player.x + player.width && py >= player.y && py <= player.y + player.height; return isOverHead || isOverBody; } else if (item.type === 'hole') { const distSqToHole = Vec.lenSq(Vec.sub({ x: px, y: py }, gameState.hole)); return distSqToHole <= (gameState.hole.radius * gameState.hole.radius); } return false; }); },
        getHandleAtPoint: (px, py) => { if (editorState.selectedItems.length !== 1 || editorState.selectedItems[0].type !== 'brick') { return null; } const brickIndex = editorState.selectedItems[0].index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return null; const brick = gameState.bricks[brickIndex]; if (!brick) return null; const handles = utils.getBrickHandles(brick); const handleHitRadiusSq = (gameState.scaledHandleSize * 1.5) * (gameState.scaledHandleSize * 1.5); if (Vec.lenSq(Vec.sub({ x: px, y: py }, handles.rotate)) <= handleHitRadiusSq * (ROTATE_HANDLE_SIZE_FACTOR * ROTATE_HANDLE_SIZE_FACTOR)) { return { type: 'rotate', itemRef: editorState.selectedItems[0], startBrickState: utils.deepClone(brick) }; } for (const type of ['tl', 'tr', 'bl', 'br']) { if (Vec.lenSq(Vec.sub({ x: px, y: py }, handles[type])) <= handleHitRadiusSq) { return { type: type, itemRef: editorState.selectedItems[0], startBrickState: utils.deepClone(brick) }; } } return null; },
        finalizeMarqueeSelection: (ctrlPressed) => { const marqueeRect = { x: Math.min(editorState.marqueeStart.x, editorState.marqueeEnd.x), y: Math.min(editorState.marqueeStart.y, editorState.marqueeEnd.y), width: Math.abs(editorState.marqueeStart.x - editorState.marqueeEnd.x), height: Math.abs(editorState.marqueeStart.y - editorState.marqueeEnd.y) }; if (marqueeRect.width < 5 && marqueeRect.height < 5) { if (!ctrlPressed) { editorState.selectedItems = []; } uiManager.updateBrickPropertiesUI(); return; } const newlySelected = []; gameState.bricks.forEach((brick, index) => { const brickBounds = utils.getRectBoundingBox(brick); if (utils.doRectsOverlap(marqueeRect, brickBounds)) { newlySelected.push({ type: 'brick', index: index }); } }); const player = gameState.player; const playerBounds = { x: player.x, y: player.y - player.headRadius, width: player.width, height: player.height + player.headRadius }; if (utils.doRectsOverlap(marqueeRect, playerBounds)) { newlySelected.push({ type: 'player', index: null }); } const holeBounds = { x: gameState.hole.x - gameState.hole.radius, y: gameState.hole.y - gameState.hole.radius, width: gameState.hole.radius * 2, height: gameState.hole.radius * 2 }; if (utils.doRectsOverlap(marqueeRect, holeBounds)) { newlySelected.push({ type: 'hole', index: null }); } if (ctrlPressed) { newlySelected.forEach(newItem => { if (!editorState.selectedItems.some(sel => sel.type === newItem.type && sel.index === newItem.index)) { editorState.selectedItems.push(newItem); } }); } else { editorState.selectedItems = newlySelected; } uiManager.updateBrickPropertiesUI(); },
        updateItemsDuringDrag: (dx, dy) => { editorState.selectedItems.forEach((item, i) => { const origState = editorState.originalItemStates[i]; if (!origState) return; if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (brick) { brick.x = origState.x + dx; brick.y = origState.y + dy; if (brick.initialX !== undefined) brick.initialX = origState.initialX + dx; if (brick.initialY !== undefined) brick.initialY = origState.initialY + dy; } } else if (item.type === 'player') { gameState.player.x = origState.x + dx; gameState.player.y = origState.y + dy; if (gameState.ball.onPlayer) gameLogic.resetBallPosition(); } else if (item.type === 'hole') { gameState.hole.x = origState.x + dx; gameState.hole.y = origState.y + dy; } }); },
        updateBrickDuringResize: (handleType, currentMouseX, currentMouseY) => { if (!editorState.draggingHandle || !editorState.draggingHandle.itemRef || editorState.draggingHandle.startBrickState === undefined) return; const brickIndex = editorState.draggingHandle.itemRef.index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; const origState = editorState.draggingHandle.startBrickState; const origAngle = origState.angle || 0; const cosA = Math.cos(-origAngle); const sinA = Math.sin(-origAngle); const ocx = origState.x + origState.width / 2; const ocy = origState.y + origState.height / 2; const dxWorld = currentMouseX - ocx; const dyWorld = currentMouseY - ocy; const localMx = dxWorld * cosA - dyWorld * sinA; const localMy = dxWorld * sinA + dyWorld * cosA; let newHalfWidth, newHalfHeight; switch (handleType) { case 'br': newHalfWidth = localMx; newHalfHeight = localMy; break; case 'bl': newHalfWidth = -localMx; newHalfHeight = localMy; break; case 'tr': newHalfWidth = localMx; newHalfHeight = -localMy; break; case 'tl': newHalfWidth = -localMx; newHalfHeight = -localMy; break; default: return; } const minScaledDim = gameState.scaledMinBrickDimension; newHalfWidth = Math.max(minScaledDim / 2, newHalfWidth); newHalfHeight = Math.max(minScaledDim / 2, newHalfHeight); const newWidth = 2 * newHalfWidth; const newHeight = 2 * newHalfHeight; const centerShiftXLocal = (newWidth - origState.width) / 2; const centerShiftYLocal = (newHeight - origState.height) / 2; let shiftFactorX = 0, shiftFactorY = 0; switch(handleType) { case 'tl': shiftFactorX = -1; shiftFactorY = -1; break; case 'tr': shiftFactorX = 1; shiftFactorY = -1; break; case 'bl': shiftFactorX = -1; shiftFactorY = 1; break; case 'br': shiftFactorX = 1; shiftFactorY = 1; break; } const finalShiftLocalX = centerShiftXLocal * shiftFactorX; const finalShiftLocalY = centerShiftYLocal * shiftFactorY; const cosARot = Math.cos(origAngle); const sinARot = Math.sin(origAngle); const centerShiftWorldX = finalShiftLocalX * cosARot - finalShiftLocalY * sinARot; const centerShiftWorldY = finalShiftLocalX * sinARot + finalShiftLocalY * cosARot; const newCx = ocx + centerShiftWorldX; const newCy = ocy + centerShiftWorldY; const localTLX = -newWidth / 2; const localTLY = -newHeight / 2; const newX = newCx + (localTLX * cosARot - localTLY * sinARot); const newY = newCy + (localTLX * sinARot + localTLY * cosARot); brick.width = newWidth; brick.height = newHeight; brick.angle = origAngle; brick.x = newX; brick.y = newY; const sizeScaleX = gameState.lastSizeScaleX || 1; const sizeScaleY = gameState.lastSizeScaleY || 1; brick.baseWidth = newWidth / sizeScaleX; brick.baseHeight = newHeight / sizeScaleY; if (brick.initialX !== undefined) brick.initialX = brick.x; if (brick.initialY !== undefined) brick.initialY = brick.y; }, // *** MODIFIED: Updates baseWidth/Height using SIZE scales ***
        updateBrickDuringRotate: (currentMouseX, currentMouseY) => { if (!editorState.draggingHandle || !editorState.draggingHandle.itemRef || editorState.draggingHandle.startBrickState === undefined) return; const brickIndex = editorState.draggingHandle.itemRef.index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; const origState = editorState.draggingHandle.startBrickState; const center = utils.getBrickHandles(origState).center; const startAngle = Math.atan2(editorState.dragStart.y - center.y, editorState.dragStart.x - center.x); const currentAngle = Math.atan2(currentMouseY - center.y, currentMouseX - center.x); brick.angle = origState.angle + (currentAngle - startAngle); brick.x = origState.x; brick.y = origState.y; brick.width = origState.width; brick.height = origState.height; },
        finalizeItemManipulation: () => { if (editorState.draggingHandle || editorState.isDraggingSelection) { editorState.selectedItems.forEach(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; if (brick) { brick.initialX = brick.x; brick.initialY = brick.y; } } }); } },
        handlePropertyChange: (event) => { if (editorState.selectedItems.length !== 1 || editorState.selectedItems[0].type !== 'brick') { return; } const brickIndex = editorState.selectedItems[0].index; if (brickIndex === undefined || brickIndex < 0 || brickIndex >= gameState.bricks.length) return; const brick = gameState.bricks[brickIndex]; if (!brick || !brick.movementType) return; const propertyName = event.target.name; const value = parseFloat(event.target.value); if (isNaN(value) || value < 0) { console.warn(`Invalid value entered for ${propertyName}:`, event.target.value); uiManager.updateBrickPropertiesUI(); return; } let valueToStore = value; if (propertyName === 'moveRange' && Math.abs(brick.moveRange - valueToStore) < 0.01) { if (brick.moveRange.toFixed(1) !== value.toFixed(1)) { uiManager.updateBrickPropertiesUI(); } return; } if (brick[propertyName] === valueToStore && propertyName === 'moveSpeed') { return; } historyManager.saveState(); brick[propertyName] = valueToStore; editorState.isUpdatingPropertiesFromInput = true; drawing.draw(); uiManager.updateBrickPropertiesUI(); editorState.isUpdatingPropertiesFromInput = false; }
    };

    // --- Event Handlers ---
    const eventHandlers = {
        handleResize: () => { utils.resizeCanvas(); },
        handleContextMenu: (e) => { e.preventDefault(); uiManager.hideContextMenu(); if (gameState.mode !== 'editor' || uiManager.isPointerOverUI(e.clientX, e.clientY)) { return; } const mx = e.clientX; const my = e.clientY; let targetItem = editor.getItemAtPoint(mx, my); let targetType = 'empty'; let targetIndex = null; if (targetItem) { targetType = targetItem.type; targetIndex = targetItem.index; if (!editorState.selectedItems.some(sel => sel.type === targetType && sel.index === targetIndex)) { editorState.selectedItems = [targetItem]; uiManager.updateBrickPropertiesUI(); drawing.draw(); } } else { editorState.selectedItems = []; uiManager.updateBrickPropertiesUI(); drawing.draw(); } editorState.contextMenuTarget = { type: targetType, index: targetIndex, x: mx, y: my }; uiManager.showContextMenu(mx, my); },
        handleMouseDown: (e) => { if (e.button !== 0 || uiManager.isPointerOverUI(e.clientX, e.clientY)) { return; } editorState.mouse.down = true; editorState.mouse.x = e.clientX; editorState.mouse.y = e.clientY; editorState.mouse.dragStartX = editorState.mouse.x; editorState.mouse.dragStartY = editorState.mouse.y; uiManager.hideContextMenu(); if (gameState.mode === 'editor') { const mx = editorState.mouse.x; const my = editorState.mouse.y; const ctrlPressed = e.ctrlKey || e.metaKey; const clickedHandle = editor.getHandleAtPoint(mx, my); if (clickedHandle) { editorState.draggingHandle = clickedHandle; editorState.dragStart = { x: mx, y: my }; historyManager.saveState(); canvas.style.cursor = clickedHandle.type === 'rotate' ? 'grabbing' : (clickedHandle.type === 'tl' || clickedHandle.type === 'br') ? 'nwse-resize' : 'nesw-resize'; editorState.isDraggingSelection = false; editorState.isMarqueeSelecting = false; } else { const clickedItem = editor.getItemAtPoint(mx, my); if (clickedItem) { const isClickOnCurrentSelection = editor.isPointOverSelection(mx, my); if (!isClickOnCurrentSelection) { editor.selectItem(clickedItem, ctrlPressed); } else if (!ctrlPressed) { if (editorState.selectedItems.length > 1) { editor.selectItem(clickedItem, false); } } else { editor.selectItem(clickedItem, true); } if (editor.isPointOverSelection(mx, my)) { editorState.isDraggingSelection = true; editorState.dragStart = { x: mx, y: my }; editorState.originalItemStates = editorState.selectedItems.map(item => { if (item.type === 'brick') { const brick = gameState.bricks[item.index]; return brick ? utils.deepClone(brick) : null; } if (item.type === 'player') return utils.deepClone(gameState.player); if (item.type === 'hole') return utils.deepClone(gameState.hole); return null; }).filter(s => s !== null); historyManager.saveState(); canvas.style.cursor = 'move'; } editorState.isMarqueeSelecting = false; } else { if (!ctrlPressed) { editorState.selectedItems = []; uiManager.updateBrickPropertiesUI(); } editorState.isMarqueeSelecting = true; editorState.marqueeStart = { x: mx, y: my }; editorState.marqueeEnd = { x: mx, y: my }; uiManager.updateMarqueeBox(); canvas.style.cursor = 'crosshair'; editorState.isDraggingSelection = false; } } drawing.draw(); } else { if (gameState.ball.onPlayer) { editorState.aim.active = true; eventHandlers.updateAim(editorState.mouse.x, editorState.mouse.y); drawing.draw(); } } },
        handleMouseMove: (e) => { editorState.mouse.x = e.clientX; editorState.mouse.y = e.clientY; const mx = editorState.mouse.x; const my = editorState.mouse.y; if (gameState.mode === 'editor') { if (editorState.mouse.down) { const dx = mx - editorState.dragStart.x; const dy = my - editorState.dragStart.y; if (editorState.draggingHandle) { const handleType = editorState.draggingHandle.type; if (handleType === 'rotate') { editor.updateBrickDuringRotate(mx, my); canvas.style.cursor = 'grabbing'; } else { editor.updateBrickDuringResize(handleType, mx, my); } drawing.draw(); } else if (editorState.isDraggingSelection) { canvas.style.cursor = 'move'; editor.updateItemsDuringDrag(dx, dy); drawing.draw(); } else if (editorState.isMarqueeSelecting) { canvas.style.cursor = 'crosshair'; editorState.marqueeEnd = { x: mx, y: my }; uiManager.updateMarqueeBox(); } } else { uiManager.updateCursorStyle(mx, my); } } else { if (editorState.aim.active && gameState.ball.onPlayer) { eventHandlers.updateAim(mx, my); drawing.draw(); } } },
        handleMouseUp: (e) => { if (e.button !== 0 || !editorState.mouse.down) return; editorState.mouse.down = false; if (gameState.mode === 'editor') { editor.finalizeItemManipulation(); if (editorState.isMarqueeSelecting) { editor.finalizeMarqueeSelection(e.ctrlKey || e.metaKey); } const dx = editorState.mouse.x - editorState.mouse.dragStartX; const dy = editorState.mouse.y - editorState.mouse.dragStartY; const isSimpleClick = Vec.lenSq({x: dx, y: dy}) < CLICK_THRESHOLD_SQ; if (isSimpleClick && (e.ctrlKey || e.metaKey)) { const clickedItem = editor.getItemAtPoint(e.clientX, e.clientY); if (clickedItem) { /* Selection handled in mousedown */ } } editor.resetSelectionAndDragging(); drawing.draw(); } else { if (editorState.aim.active && gameState.ball.onPlayer) { gameLogic.fireBall(); editorState.aim.active = false; drawing.draw(); } } uiManager.updateCursorStyle(e.clientX, e.clientY); },
        handleKeyDown: (e) => { if (uiManager.isPointerOverUI(editorState.mouse.x, editorState.mouse.y)) { const isInputFocused = document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA'); if (!isInputFocused && e.key.length === 1) { /* Block typing */ } else { return; } } if (gameState.mode !== 'editor') return; const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable); const ctrlPressed = e.ctrlKey || e.metaKey; if (isInputFocused) { if (ctrlPressed && ['a', 'c', 'v', 'x', 'z', 'y'].includes(e.key.toLowerCase())) { return; } if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Delete', 'Backspace', 'Home', 'End', 'Tab'].includes(e.key)) { return; } if (!ctrlPressed && !e.altKey && e.key.length === 1) { return; } if (['Delete', 'Backspace'].includes(e.key) && !ctrlPressed) return; if (e.key.startsWith('Arrow')) return; if (e.key === 'Escape') { activeEl.blur(); return; } e.preventDefault(); return; } if (ctrlPressed && e.key.toLowerCase() === 'z') { e.preventDefault(); historyManager.undo(); return; } if (ctrlPressed && (e.key.toLowerCase() === 'y' || (e.key.toLowerCase() === 'z' && e.shiftKey))) { e.preventDefault(); historyManager.redo(); return; } if (ctrlPressed && e.key.toLowerCase() === 'c') { e.preventDefault(); editor.handleCopy(); return; } if (ctrlPressed && e.key.toLowerCase() === 'v') { e.preventDefault(); editor.handlePaste(); return; } if ((e.key === "Delete" || e.key === "Backspace") && editorState.selectedItems.length > 0) { e.preventDefault(); editor.deleteSelectedItems(); return; } let dx = 0, dy = 0; switch (e.key) { case "ArrowUp": dy = -NUDGE_AMOUNT; break; case "ArrowDown": dy = NUDGE_AMOUNT; break; case "ArrowLeft": dx = -NUDGE_AMOUNT; break; case "ArrowRight": dx = NUDGE_AMOUNT; break; default: return; } if (dx !== 0 || dy !== 0) { e.preventDefault(); editor.handleNudge(dx, dy); } },
        handleKeyUp: (e) => { if (gameState.mode !== 'editor') return; if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) { if (editorState.isNudging) { editorState.isNudging = false; } } },
        updateAim: (mx, my) => { if (!gameState.ball.onPlayer) return; const aimVecRaw = Vec.sub({ x: mx, y: my }, { x: gameState.ball.x, y: gameState.ball.y }); let aimPowerLength = Vec.len(aimVecRaw); aimPowerLength = Math.min(aimPowerLength, gameState.scaledAimLineLength); const power = aimPowerLength / AIM_POWER_FACTOR; const normAimVec = Vec.normalize(aimVecRaw); editorState.aim.dx = normAimVec.x * power; editorState.aim.dy = normAimVec.y * power; if (editorState.aim.dy > MIN_AIM_VY) { editorState.aim.dy = MIN_AIM_VY; } }
    };


    // --- Game Loop ---
    let lastTimestamp = 0;
    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        gameLogic.update(deltaTime);
        drawing.draw();

        requestAnimationFrame(gameLoop);
    }

    // --- Initialization ---
    async function init() {
        console.log("Initializing Bounce Back...");
        window.addEventListener("resize", eventHandlers.handleResize);
        canvas.addEventListener("contextmenu", eventHandlers.handleContextMenu);
        canvas.addEventListener("mousedown", eventHandlers.handleMouseDown);
        canvas.addEventListener("mousemove", eventHandlers.handleMouseMove);
        canvas.addEventListener("mouseup", eventHandlers.handleMouseUp);
        canvas.addEventListener("mouseleave", () => {
            if (editorState.mouse.down) {
                eventHandlers.handleMouseUp({ button: 0, clientX: editorState.mouse.x, clientY: editorState.mouse.y });
            }
            if (editorState.aim.active) {
                 editorState.aim.active = false;
                 drawing.draw();
            }
        });
        document.addEventListener("keydown", eventHandlers.handleKeyDown);
        document.addEventListener("keyup", eventHandlers.handleKeyUp);

        playButton.onclick = gameLogic.startGame;
        editorButton.onclick = gameLogic.switchToEditorMode;
        showMenuButton.onclick = uiManager.showMenu;

        propMoveRangeInput.addEventListener('input', editor.handlePropertyChange);
        propMoveSpeedInput.addEventListener('input', editor.handlePropertyChange);

        startGameButton.addEventListener('click', () => {
            startMenu.classList.add('hidden');
            canvas.classList.remove('hidden');
            menuDiv.classList.remove('initially-hidden');
            uiManager.showMenu();
            utils.resizeCanvas(); // Resize now that canvas is visible, applies scaling via loadLevelData
            gameLogic.startGame(); // Start game in play mode
        });

        await levelManager.loadLevelsFromStorage(); // Loads unscaled data into levelManager.levels
        utils.resizeCanvas(); // Initial resize sets canvas size but loadLevelData is skipped

        lastTimestamp = performance.now();
        requestAnimationFrame(gameLoop);
        console.log("Initialization Complete. Showing Start Menu.");
    }

    // --- Start the application ---
    init();

</script>

</body>
</html>
